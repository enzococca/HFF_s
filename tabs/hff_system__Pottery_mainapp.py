#! /usr/bin/env python# -*- coding: utf 8 -*-"""/***************************************************************************        HFF_system Plugin  - A QGIS plugin to manage archaeological dataset                             stored in Postgres                             -------------------    begin                : 2007-12-01    copyright            : (C) 2008 by Luca Mandolesi    email                : mandoluca at gmail.com ***************************************************************************//*************************************************************************** *                                                                                                                  * *   This program is free software; you can redistribute it and/or modify                           * *   it under the terms of the GNU General Public License as published by                       * *   the Free Software Foundation; either version 2 of the License, or                              * *   (at your option) any later version.                                                                    * *                                                                                                                  * ***************************************************************************/"""from __future__ import absolute_importimport osfrom datetime import dateimport sysimport reimport platformfrom pdf2docx import parseimport numpy as npfrom builtins import rangefrom builtins import strfrom datetime import datefrom qgis.core import *from qgis.PyQt.QtCore import *from qgis.PyQt.QtGui import QColor, QIconfrom qgis.PyQt.QtWidgets import *from qgis.PyQt.QtSql import QSqlDatabase, QSqlTableModelfrom qgis.PyQt.uic import loadUiTypefrom qgis.gui import QgsMapCanvas, QgsMapToolPanfrom ..modules.utility.hff_system__exp_POTTERYsheet_pdf import generate_POTTERY_pdffrom ..modules.utility.hff_system__OS_utility import Hff_OS_Utilityfrom ..modules.db.hff_system__conn_strings import Connectionfrom ..modules.db.hff_db_manager import Hff_db_managementfrom ..modules.db.hff_system__utility import Utilityfrom ..modules.gis.hff_system__pyqgis import Hff_pyqgisfrom ..modules.utility.delegateComboBox import ComboBoxDelegatefrom ..modules.utility.hff_system__error_check import Error_checkfrom ..modules.utility.csv_writer import UnicodeWriterfrom ..gui.imageViewer import ImageViewerfrom ..gui.sortpanelmain import SortPanelMainfrom ..gui.quantpanelmain import QuantPanelMainMAIN_DIALOG_CLASS, _ = loadUiType(    os.path.join(os.path.dirname(__file__), os.pardir, 'gui', 'ui', 'hff_system__Pottery_ui.ui'))class hff_system__Pottery(QDialog, MAIN_DIALOG_CLASS):    L=QgsSettings().value("locale/userLocale")[0:2]    MSG_BOX_TITLE = "HFF - Pottery Form"    DATA_LIST = []    DATA_LIST_REC_CORR = []    DATA_LIST_REC_TEMP = []    REC_CORR = 0    REC_TOT = 0    STATUS_ITEMS = {"b": "Current", "f": "Find", "n": "New Record"}    BROWSE_STATUS = "b"    SORT_MODE = 'asc'    SORTED_ITEMS = {"n": "Not sorted", "o": "Sorted"}    SORT_STATUS = "n"    SORT_ITEMS_CONVERTED = ''    UTILITY = Utility()    DB_MANAGER = ""    TABLE_NAME = 'pottery_table'    MAPPER_TABLE_CLASS = "POTTERY"    NOME_SCHEDA = "Pottery Form"    ID_TABLE = "id_rep"    ID_SITO ="site"    CONVERSION_DICT = {    ID_TABLE:ID_TABLE,    "Divelog":"divelog_id",    "Site":"site",    "Date":"date_",    "Artefact":"artefact_id",    "Photo":"photographed",    "Drawing":"drawing",    "Retrevied":"retrieved",    "Inclusions":"inclusions",    "Percent of the incl.":"percent_inclusion",    "Specific part":"specific_part",    "Form":"form",    "Typology":"typology",    "Provenance":"provenance",    "Munsell Clay":"munsell_clay",    "Surface treatment":"surf_treatment",    "Conservation":"conservation",    "Depth":"depth",    "Storage":"storage_",    "Period":"period",    "State":"state",    "Samples":"samples",    "Washed":"washed",    "Diameter max":"dm",    "Diameter rim":"dr",    "Diameter bottom":"db",     "Total height":"th",    "Preserved Height":"ph",    "Base Height":"bh",    "T Min":"thickmin",    "T max":"thickmax",    "Year":"years",    "Box":"box",    "Biblio":"biblio",    "Decription":"description",    "Area":"area",    "Munsell Surfaces":"munsell_surf",    "Category":"category",    "Wheel Made":"wheel_made",    "List Number":"qty",    }    SORT_ITEMS = [                ID_TABLE,                 "Divelog",                "Site",                "Date",                "Artefact",                "Photo",                "Drawing",                "Retrevied",                "Inclusions",                "Percent of the incl.",                "Specific part",                "Form",                "Typology",                "Provenance",                "Munsell Clay",                "Surface treatment",                "Conservation",                "Depth",                "Storage",                "Period",                "State",                "Sample",                "Washed",                "Diametro max",                "Diametro rim",                "Diametro bottom",                 "Total height",                "Preserved Height",                "Base Height",                "T Min",                "T max",                "Year",                "Box",                "Biblio",                "Decription",                "Area",                "Munsell Surfaces",                "Category",                "Wheel Made"                #"List Number"                ]    QUANT_ITEMS = [                'Divelog',                'Site',                'Date',                'Artefact',                'Photo',                'Drawing',                'Retrevied',                'Inclusions',                'Percent of the incl.',                'Specific part',                'Form',                'Typology',                'Provenance',                'Munsell Clay',                'Surface treatment',                'Conservation',                'Depth',                'Storage',                'Period',                'State',                'Sample',                'Washed',                'Diameter max',                'Diameter rim',                'Diameter bottom',                  'Total height',                'Preserved Height',                'Base Height',                'T Min',                'T max',                'Year',                'Box',                'Biblio',                'Decription',                'Area',                'Category',                'Wheel Made'                ]    TABLE_FIELDS_UPDATE = [                    "divelog_id",                    "site",                    "date_",                    "artefact_id",                    "photographed",                    "drawing",                    "retrieved",                    "inclusions",                    "percent_inclusion",                    "specific_part",                    "form",                    "typology",                    "provenance",                    "munsell_clay",                    "surf_treatment",                    "conservation",                    "depth",                    "storage_",                    "period",                    "state",                    "samples",                    "washed",                    "dm",                    "dr",                    "db",                    "th",                    "ph",                    "bh",                    "thickmin",                    "thickmax",                    "years",                    "box",                    "biblio",                    "description",                    "area",                    "munsell_surf",                    "category",                    "wheel_made",                    "qty"                    ]                           TABLE_FIELDS = [                    'divelog_id',                    'site',                    'date_',                    'artefact_id',                    'photographed',                    'drawing',                    'retrieved',                    'inclusions',                    'percent_inclusion',                    'specific_part',                    'form',                    'typology',                    'provenance',                    'munsell_clay',                    'surf_treatment',                    'conservation',                    'depth',                    'storage_',                    'period',                    'state',                    'samples',                    'washed',                    'dm',                    'dr',                    'db',                    'th',                    'ph',                    'bh',                    'thickmin',                    'thickmax',                    'years',                    'box',                    'biblio',                    'description',                    'area',                    'munsell_surf',                    'category',                    'wheel_made',                    'qty'                    ]    SEARCH_DICT_TEMP = ""    HOME = os.environ['HFF_HOME']    PDFFOLDER = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")    DB_SERVER = "not defined"  ####nuovo sistema sort    QUANT_PATH = '{}{}{}'.format(HOME, os.sep, "HFF_statistic_folder")    def __init__(self, iface):        super().__init__()        self.iface = iface        self.pyQGIS = Hff_pyqgis(iface)        self.setupUi(self)        self.mDockWidget_4.setHidden(True)        self.mDockWidget_2.setHidden(True)        self.mDockWidget_export.setHidden(True)        self.currentLayerId = None        #HOME = os.environ['HFF_HOME']        try:            self.on_pushButton_connect_pressed()        except Exception as e:            QMessageBox.warning(self, "Connection System", str(e), QMessageBox.Ok)        site = self.comboBox_site_name.currentText()        self.comboBox_site_name.setEditText(site)        self.search_1.textChanged.connect(self.update_filter)        self.checkBox_query.update()        self.checkBox_query.stateChanged.connect(self.listview_us)###anche questo        self.toolButton_pdfpath.clicked.connect(self.setPathpdf)        self.pbnOpenpdfDirectory.clicked.connect(self.openpdfDir)        self.empty_fields()        self.fill_fields()        self.customize_GUI()        self.show()        #self.loadMedialist()    def setPathpdf(self):        s = QgsSettings()        dbpath = QFileDialog.getOpenFileName(            self,            "Set file name",            self.PDFFOLDER,            " PDF (*.pdf)"        )[0]        #filename=dbpath.split("/")[-1]        if dbpath:            self.lineEdit_pdf_path.setText(dbpath)            s.setValue('',dbpath)     def openpdfDir(self):        HOME = os.environ['HFF_HOME']        path = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])        def on_pushButton_convert_pressed(self):        # if not bool(self.setPathpdf()):                # QMessageBox.warning(self, "INFO", "devi scegliere un file pdf",                                # QMessageBox.Ok)        try:            pdf_file = self.lineEdit_pdf_path.text()            filename=pdf_file.split("/")[-1]            docx_file = self.PDFFOLDER+'/'+filename+'.docx'            # convert pdf to docx            parse(pdf_file, docx_file, start=self.lineEdit_pag1.text(), end=self.lineEdit_pag2.text())                        QMessageBox.information(self, "INFO", "Conversion completed",                                QMessageBox.Ok)        except Exception as e:            QMessageBox.warning(self, "Error", str(e),                                QMessageBox.Ok)        def on_pushButtonQuant_pressed(self):        dlg = QuantPanelMain(self)        dlg.insertItems(self.QUANT_ITEMS)        dlg.exec_()        dataset = []        parameter1 = dlg.TYPE_QUANT        parameters2 = dlg.ITEMS        contatore = 0        if parameter1 == 'QTY':            for i in range(len(self.DATA_LIST)):                temp_dataset = ()                try:                    temp_dataset = (self.parameter_quant_creator(parameters2, i), int(self.DATA_LIST[i].box))                    contatore += int(self.DATA_LIST[i].box) #conteggio totale                    dataset.append(temp_dataset)                except:                    pass            #QMessageBox.warning(self, "Totale", str(contatore),  QMessageBox.Ok)            if bool(dataset):                dataset_sum = self.UTILITY.sum_list_of_tuples_for_value(dataset)                csv_dataset = []                for sing_tup in dataset_sum:                    sing_list = [sing_tup[0], str(sing_tup[1])]                    csv_dataset.append(sing_list)                filename = ('%s%squant_qty.txt') % (self.QUANT_PATH, os.sep)                #QMessageBox.warning(self, "Esportazione", str(filename), MessageBox.Ok)                f = open(filename, 'wb')                Uw = UnicodeWriter(f)                Uw.writerows(csv_dataset)                f.close()                self.plot_chart(dataset_sum, 'Frequency analisys', 'Qty')            else:                QMessageBox.warning(self, "Warning", "The datas not are present",  QMessageBox.Ok)    def parameter_quant_creator(self, par_list, n_rec):        self.parameter_list = par_list        self.record_number = n_rec        converted_parameters = []        for par in self.parameter_list:            converted_parameters.append(self.CONVERSION_DICT[par])        parameter2 = ''        for sing_par_conv in range(len(converted_parameters)):            exec_str =  ('str(self.DATA_LIST[%d].%s)') % (self.record_number, converted_parameters[sing_par_conv])            paramentro = str(self.parameter_list[sing_par_conv])            exec_str = ' -' + paramentro[:4] + ": " + eval(exec_str)            parameter2 += exec_str        return parameter2    def plot_chart(self, d, t, yl):        self.data_list = d        self.title = t        self.ylabel = yl        if type(self.data_list) == list:            data_diz = {}            for item in self.data_list:                data_diz[item[0]] = item[1]        x = list(range(len(data_diz)))        n_bars = len(data_diz)        values = list(data_diz.values())        teams = list(data_diz.keys())        ind = np.arange(n_bars)        #randomNumbers = random.sample(range(0, 10), 10)        self.widget.canvas.ax.clear()        #QMessageBox.warning(self, "Alert", str(teams) ,  QMessageBox.Ok)        bars = self.widget.canvas.ax.bar(x, height=values, width=0.5, align='center', alpha=0.4,picker=5)        #guardare il metodo barh per barre orizzontali        self.widget.canvas.ax.set_title(self.title)        self.widget.canvas.ax.set_ylabel(self.ylabel)        l = []        for team in teams:            l.append('""')        #self.widget.canvas.ax.set_xticklabels(x , ""   ,size = 'x-small', rotation = 0)        n = 0        for bar in bars:            val = int(bar.get_height())            x_pos = bar.get_x() + 0.25            label  = teams[n]+ ' - ' + str(val)            y_pos = 0.1 #bar.get_height() - bar.get_height() + 1            self.widget.canvas.ax.tick_params(axis='x', labelsize=8)            #self.widget.canvas.ax.set_xticklabels(ind + x, ['fg'], position = (x_pos,y_pos), xsize = 'small', rotation = 90)            self.widget.canvas.ax.text(x_pos, y_pos, label,zorder=0, ha='center', va='bottom',size = 'x-small', rotation = 90)            n+=1        #self.widget.canvas.ax.plot(randomNumbers)        self.widget.canvas.draw()    def enable_button(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_new_search.setEnabled(n)        self.pushButton_search_go.setEnabled(n)        self.pushButton_sort.setEnabled(n)    def enable_button_search(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_save.setEnabled(n)        self.pushButton_sort.setEnabled(n)        self.pushButton_sort.setEnabled(n)            def on_pushButton_connect_pressed(self):        """This method establishes a connection between GUI and database"""        conn = Connection()        conn_str = conn.conn_str()        test_conn = conn_str.find('sqlite')        if test_conn == 0:            self.DB_SERVER = "sqlite"        try:            self.DB_MANAGER = Hff_db_management(conn_str)            self.DB_MANAGER.connection()            self.charge_records()  # charge records from DB            # check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = 'b'                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()            else:                QMessageBox.warning(self,"WELCOME HFF user", "Welcome in HFF survey:" + " Site form." + " The DB is empty. Push 'Ok' and Good Work!",                                    QMessageBox.Ok)                self.charge_list()                self.BROWSE_STATUS = 'x'                self.on_pushButton_new_rec_pressed()        except Exception as e:            e = str(e)            if e.find("no such table"):                msg = "The connection failed {}. " \                      "You MUST RESTART QGIS or bug detected! Report it to the developer".format(str(e))            else:                msg = "Warning bug detected! Report it to the developer. Error: ".format(str(e))                self.iface.messageBar().pushMessage(self.tr(msg), Qgis.Warning, 0)    def customize_GUI(self):        # self.tableWidget_foto.setColumnWidth(0, 100)        # self.tableWidget_foto.setColumnWidth(1, 100)        # self.tableWidget_foto.setColumnWidth(2, 100)        # self.tableWidget_foto.setColumnWidth(3, 100)        # self.tableWidget_foto.setColumnWidth(4, 200)        #media prevew system        self.iconListWidget.setLineWidth(2)        self.iconListWidget.setMidLineWidth(2)        #self.iconListWidget.setLineHigth(4)        self.iconListWidget.setProperty("showDropIndicator", True)        self.iconListWidget.setIconSize(QSize(200, 200))        self.iconListWidget.setMovement(QListView.Snap)        self.iconListWidget.setResizeMode(QListView.Adjust)        #self.iconListWidget.setLayoutMode(QtGui.QListView.Batched)        #self.iconListWidget.setGridSize(QtCore.QSize(2000, 1000))        self.iconListWidget.setViewMode(QListView.IconMode)        self.iconListWidget.setUniformItemSizes(True)        #self.iconListWidget.setBatchSize(1500)        self.iconListWidget.setObjectName("iconListWidget")        self.iconListWidget.SelectionMode()        self.iconListWidget.setSelectionMode(QAbstractItemView.SingleSelection)        self.iconListWidget.itemDoubleClicked.connect(self.openWide_image)            # def loadMedialist(self):        # self.tableWidget_foto.clear()        # col =['Site','Area','Artefact ID','Specific Part']        # self.tableWidget_foto.setHorizontalHeaderLabels(col)        # numRows = self.tableWidget_foto.setRowCount(100)        # list_=[]        # try:             # search_dict = {                # 'site': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]. " + self.ID_SITO)) + "'"}            # record_us_list = self.DB_MANAGER.query_bool(search_dict, 'POTTERY')            # nus=0            # for b in record_us_list:                # if nus== 0:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.site)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.area)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.specific_part)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.artefact_id)))                        # nus+=1                # else:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.site)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.area)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.specific_part)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.artefact_id)))                        # nus+=1         # except:            # pass                        # search_dict = {            # 'id_entity': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE)) + "'",            # 'entity_type': "'US'"}        # record_media_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')        # n=0        # for a in record_media_list:                        # if n== 0:                # self.tableWidget_foto.setItem(n, 3,QTableWidgetItem(str(a.media_name)))                # n+=1            # else:                # self.tableWidget_foto.setItem(n, 3,QTableWidgetItem(str(a.media_name)))                # n+=1                def listview_us(self):        if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()            conn_sqlite = conn.databasename()            conn_user = conn.datauser()            conn_host = conn.datahost()            conn_port = conn.dataport()            port_int  = conn_port["port"]            port_int.replace("'", "")            conn_password = conn.datapassword()            #sito_set= conn.sito_set()            #sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            if test_conn == 0:                sqlite_DB_path = '{}{}{}'.format(self.HOME, os.sep,                                               "HFF_DB_folder")                 db = QSqlDatabase("QSQLITE")                 db.setDatabaseName(sqlite_DB_path +os.sep+ conn_sqlite["db_name"])                db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                 self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                column_titles = {                     "site":"SITE",                    "artefact_id": "ArtefactID"}                 for n, t in column_titles.items():                     idx = self.model_a.fieldIndex( n)                     self.model_a.setHeaderData( idx, Qt.Horizontal, t)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                 # else:                self.model_a.select()             else:                db = QSqlDatabase.addDatabase("QPSQL")                db.setHostName(conn_host["host"])                db.setDatabaseName(conn_sqlite["db_name"])                db.setPort(int(port_int))                db.setUserName(conn_user['user'])                db.setPassword(conn_password['password'])                 db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                # else:                self.model_a.select()         else:            self.checkBox_query.setChecked(False)    def submit(self):        if self.checkBox_query.isChecked():            self.model_a.database().transaction()            if self.model_a.submitAll():                self.model_a.database().commit()                if self.L=='it':                    QMessageBox.information(self, "Record",  "record salvato")                elif self.L=='de':                    QMessageBox.information(self, "Datensatz",  "Datensatz gespeichert")                else:                    QMessageBox.information(self, "Record",  "record saved")                        else:                self.model_a.database().rollback()                if self.L=='it':                    QMessageBox.warning(self, "Cached Table",                            "Il db ha segnalato un errore: %s" % self.model_a.lastError().text())                            elif self.L=='de':                    QMessageBox.warning(self, "Cached Table",                            "Die Datenbank meldete einen Fehler: %s" % self.model_a.lastError().text())                                                else:                    QMessageBox.warning(self, "Cached Table",                            "The database reported an error: %s" % self.model_a.lastError().text())                                else:                self.checkBox_query.setChecked(False)    def update_filter(self, s):         if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()                # sito_set= conn.sito_set()            # sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            s_field = self.field.currentText()            s = re.sub("[\W_] +", "", s)            if test_conn == 0:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                         # self.model_a.setFilter(filter_str)                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     self.model_a.setFilter(filter_str)                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)            else:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                        # if bool(filter_str):                            # self.model_a.setFilter(filter_str)                            # self.model_a.select()                        # else:                            # pass                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     if bool(filter_str):                        self.model_a.setFilter(filter_str)                        self.model_a.select()                     else:                        pass                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)        else:                self.checkBox_query.setChecked(False)        def on_pushButton_go_to_scheda_pressed(self):        if self.L=='it':            QMessageBox.warning(self, "ATTENZIONE", "Se hai modificato il record e non lo hai salvato perderai il dato. Salvare?", QMessageBox.Ok | QMessageBox.Cancel)        else:            QMessageBox.warning(self, "Warning", "If you changed the record and didn't save it, you'll lose the record. Do you want save it?", QMessageBox.Ok | QMessageBox.Cancel)                        try:            #table_name = "self.table"            #rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            rowSelected = self.table.currentIndex()#eval(rowSelected_cmd)            rowIndex = rowSelected.row()            sito_item = self.table.model().index(rowIndex,31)            area_item = self.table.model().index(rowIndex,0)            #us = str(self.lineEdit_us.text())            us_item = self.table.model().index(rowIndex,27)            #for i in us_item:            sito =self.table.model().data(sito_item)            divelog_id= self.table.model().data(area_item)            years = self.table.model().data(us_item)            search_dict = {'site': "'" + str(sito) + "'",                           'artefact_id': "'" + str(divelog_id) + "'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)            self.empty_fields()            self.DATA_LIST = []            for i in res:                self.DATA_LIST.append(i)            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.fill_fields()            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)        except Exception as e:            e = str(e)            if self.L=='it':                QMessageBox.warning(self, "Alert", "Non hai selezionato nessuna riga. Errore python: %s " % (str(e)),                                QMessageBox.Ok)            elif self.L=='de':                QMessageBox.warning(self, "ACHTUNG", "Keine Spalte ausgewält. Error python: %s " % (str(e)),                                QMessageBox.Ok)            else:                QMessageBox.warning(self, "Alert", "You didn't select any row. Python error: %s " % (str(e)),                                QMessageBox.Ok)         def charge_list(self):        #lista sito        sito_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('site_table', 'location_', 'SITE'))        try:            sito_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_site_name.clear()        sito_vl.sort()        self.comboBox_site_name.addItems(sito_vl)                #lista sito        artefact_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'artefact_id', 'POTTERY'))        try:            artefact_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_artefact.clear()        artefact_vl.sort()        self.comboBox_artefact.addItems(artefact_vl)                #--------------------------------------------------------------------------------------------------------------------------------        forma_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'form', 'POTTERY'))        try:            forma_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in form list: " + str(e), QMessageBox.Ok)        self.comboBox_form.clear()        forma_vl.sort()        self.comboBox_form.addItems(forma_vl)        #--------------------------------------------------------------------------------------------------------------------------------                        munsell_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'munsell_clay', 'POTTERY'))        try:            munsell_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in munsell list: " + str(e), QMessageBox.Ok)        self.comboBox_munsell_clay.clear()        munsell_vl.sort()        self.comboBox_munsell_clay.addItems(munsell_vl)                #--------------------------------------------------------------------------------------------------------------------------------        # forma_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'form', 'POTTERY'))        # try:            # forma_vl.remove('')        # except Exception as e:            # if str(e) == "list.remove(x): x not in list":                # pass            # else:                # QMessageBox.warning(self, "Message", "Update system in form list: " + str(e), QMessageBox.Ok)        # self.comboBox_form.clear()        # forma_vl.sort()        # self.comboBox_form.addItems(forma_vl)        #--------------------------------------------------------------------------------------------------------------------------------        treatment_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'conservation', 'POTTERY'))        try:            treatment_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in conservation list: " + str(e), QMessageBox.Ok)        self.comboBox_conservation.clear()        treatment_vl.sort()        self.comboBox_conservation.addItems(treatment_vl)        #--------------------------------------------------------------------------------------------------------------------------------        samples_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'samples', 'POTTERY'))        try:            samples_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in samples list: " + str(e), QMessageBox.Ok)        self.comboBox_samples.clear()        samples_vl.sort()        self.comboBox_samples.addItems(samples_vl)                #--------------------------------------------------------------------------------------------------------------------------------        munsell_surf_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'munsell_surf', 'POTTERY'))        try:            munsell_surf_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in musell surf list: " + str(e), QMessageBox.Ok)        try:            self.comboBox_munsell_surf.clear()            munsell_surf_vl.sort()            self.comboBox_munsell_surf.addItems(munsell_surf_vl)        except:            pass                #--------------------------------------------------------------------------------------------------------------------------------        area_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('pottery_table', 'area', 'POTTERY'))        try:            area_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in area list: " + str(e), QMessageBox.Ok)        self.comboBox_area.clear()        area_vl.sort()        self.comboBox_area.addItems(area_vl)        #--------------------------------------------------------------------------------------------------------------------------------        # #lista years reference        # anno = ['','2013', '2014', '2015', '2016', '2017', '2018',                # '2019', '2020']        # self.comboBox_year.clear()        # self.comboBox_year.addItems(anno)    def on_toolButtonPreviewMedia_toggled(self):        if bool(self.toolButtonPreviewMedia.isChecked()):            QMessageBox.warning(self, "Message",                                    "Pottery Media Preview mode enabled. Pottery images will be displayed in the Media section", QMessageBox.Ok)            self.loadMediaPreview()        else:            self.loadMediaPreview(1)        def on_pushButton_sort_pressed(self):        if self.check_record_state() == 1:            pass        else:            dlg = SortPanelMain(self)            dlg.insertItems(self.SORT_ITEMS)            dlg.exec_()            items,order_type = dlg.ITEMS, dlg.TYPE_ORDER            self.SORT_ITEMS_CONVERTED = []            for i in items:                #QMessageBox.warning(self, "Messaggio",i, QMessageBox.Ok)                self.SORT_ITEMS_CONVERTED.append(self.CONVERSION_DICT[str(i)]) #apportare la modifica nellle altre schede            self.SORT_MODE = order_type            self.empty_fields()            id_list = []            for i in self.DATA_LIST:                id_list.append(eval("i." + self.ID_TABLE))            self.DATA_LIST = []            temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE, self.MAPPER_TABLE_CLASS, self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)            self.BROWSE_STATUS = 'b'            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.SORT_STATUS = "o"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)            self.fill_fields()    def insert_new_row(self, table_name):        """insert new row into a table based on table_name"""        cmd = table_name+".insertRow(0)"        eval(cmd)    def remove_row(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        try:            rowIndex = (rowSelected[1].row())            cmd = ("%s.removeRow(%d)") % (table_name, rowIndex)            eval(cmd)        except:            QMessageBox.warning(self, "Message", "select a row",  QMessageBox.Ok)    def on_pushButton_new_rec_pressed(self):        if bool(self.DATA_LIST):            if self.data_error_check() == 1:                pass            else:                if self.BROWSE_STATUS == "b":                    if self.DATA_LIST:                        if self.records_equal_check() == 1:                            self.update_if(QMessageBox.warning(self, 'Error',                                                               "The record has been changed. Do you want to save the changes?",                                                               QMessageBox.Ok | QMessageBox.Cancel))                            # set the GUI for a new record        if self.BROWSE_STATUS != "n":            self.BROWSE_STATUS = "n"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.empty_fields()            self.label_sort.setText(self.SORTED_ITEMS["n"])            # self.setComboBoxEnable(["self.comboBox_site_name"], "True")            # self.setComboBoxEditable(["self.comboBox_site_name"], 1)            self.setComboBoxEnable(["self.comboBox_artefact"], "True")            self.setComboBoxEditable(["self.comboBox_artefact"], 1)                        self.set_rec_counter('', '')            self.enable_button(0)    def on_toolButtonGis_toggled(self):        if self.toolButtonGis.isChecked() == True:            QMessageBox.warning(self, "Message", "GIS mode activated. From now on what you search will be shown in GIS", QMessageBox.Ok)        else:            QMessageBox.warning(self, "Message", "GIS mode deactivated. From now on what you search will not be shown in GIS", QMessageBox.Ok)    def on_pushButton_save_pressed(self):        # save record        if self.BROWSE_STATUS == "b":            if self.data_error_check() == 0:                if self.records_equal_check() == 1:                    self.update_if(QMessageBox.warning(self, 'Error',                                                       "The record has been changed. Do you want to save the changes?",                                                       QMessageBox.Ok | QMessageBox.Cancel))                    self.empty_fields()                    self.SORT_STATUS = "n"                    self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])                    self.enable_button(1)                    self.fill_fields(self.REC_CORR)                else:                    QMessageBox.warning(self, "Warning", "No changes have been made", QMessageBox.Ok)        else:            if self.data_error_check() == 0:                test_insert = self.insert_new_rec()                if test_insert == 1:                    self.empty_fields()                    self.label_sort.setText(self.SORTED_ITEMS["n"])                    self.charge_list()                    self.charge_records()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                    # self.setComboBoxEnable(["self.comboBox_artefact"], "True")                                        # self.setComboBoxEnable(["self.comboBox_site_name"], "True")                                       self.fill_fields(self.REC_CORR)                    self.enable_button(1)                else:                    pass    def insert_new_rec(self):        ##rif_biblio        biblio = self.table2dict("self.tableWidget_rif_biblio")        #decoration =self.table2dict("self.tableWidget_dec")         # if self.lineEdit_divelog_id.text() == "":            # divelog_id = 0        # else:            # divelog_id = int(self.lineEdit_divelog_id.text())        # if self.lineEdit_dm.text() == "":            # dm = None        # else:            # dm = float(self.lineEdit_dm.text())        # if self.lineEdit_dr.text() == "":            # dr = None        # else:            # dr = float(self.lineEdit_dr.text())        # if self.lineEdit_db.text() == "":            # db = None        # else:            # db = float(self.lineEdit_db.text())        # if self.lineEdit_th.text() == "":            # th = None        # else:            # th = float(self.lineEdit_th.text())        # if self.lineEdit_ph.text() == "":            # ph = None        # else:            # ph = float(self.lineEdit_ph.text())        # if self.lineEdit_bh.text() == "":            # bh = None        # else:            # bh = float(self.lineEdit_bh.text())        # if self.lineEdit_thickmin.text() == "":            # thickmin = None        # else:            # thickmin = float(self.lineEdit_thickmin.text())        # if self.lineEdit_thickmax.text() == "":            # thickmax = None        # else:            # thickmax = float(self.lineEdit_thickmax.text())        if self.comboBox_year.currentText() == "":            years = ''        else:            years = int(self.comboBox_year.currentText())        if self.lineEdit_box.text() == "":            box = 1        else:            box = int(self.lineEdit_box.text())        if self.lineEdit_qty.text() == "":            qty = 1        else:            qty = int(self.lineEdit_qty.text())                   try:            data = self.DB_MANAGER.insert_pottery_values(            self.DB_MANAGER.max_num_id(self.MAPPER_TABLE_CLASS, self.ID_TABLE)+1,                    int(self.lineEdit_divelog_id.text()),                    str(self.comboBox_site_name.currentText()),                    str(self.lineEdit_date.text()),                    str(self.comboBox_artefact.currentText()),                    str(self.comboBox_photo.currentText()),                    str(self.comboBox_draw.currentText()),                    str(self.comboBox_ret.currentText()),                    str(self.comboBox_inclusions.currentText()),                    str(self.comboBox_percent_inclusion.currentText()),                    str(self.comboBox_specific_form.currentText()),                    str(self.comboBox_form.currentText()),                    str(self.comboBox_typology.currentText()),                    str(self.lineEdit_provenance.text()),                    str(self.comboBox_munsell_clay.currentText()),                    str(self.comboBox_surf_treatment.currentText()),                    str(self.comboBox_conservation.currentText()),                    str(self.lineEdit_depth.text()),                    str(self.lineEdit_storage_.text()),                    str(self.lineEdit_period.text()),                    str(self.lineEdit_state.text()),                    str(self.comboBox_samples.currentText()),                    str(self.comboBox_washed.currentText()),                    str(self.lineEdit_dm.text()),                    str(self.lineEdit_dr.text()),                    str(self.lineEdit_db.text()),                    str(self.lineEdit_th.text()),                    str(self.lineEdit_ph.text()),                    str(self.lineEdit_bh.text()),                    str(self.lineEdit_thickmin.text()),                    str(self.lineEdit_thickmax.text()),                    years,                    box,                    str(biblio),                    str(self.textEdit_description.toPlainText()),                    str(self.comboBox_area.currentText()),                    str(self.comboBox_munsell_surf.currentText()),                    str(self.comboBox_category.currentText()),                    str(self.comboBox_wheelmade.currentText()),                    qty                    )                                     try:                self.DB_MANAGER.insert_data_session(data)                return 1            except Exception as e:                e_str = str(e)                if e_str.__contains__("IntegrityError"):                    msg = self.ID_TABLE + " exist in db"                    QMessageBox.warning(self, "Error", "Error" + str(msg), QMessageBox.Ok)                  else:                    msg = e                    QMessageBox.warning(self, "Error", "Error 1 \n" + str(msg), QMessageBox.Ok)                return 0        except Exception as e:            QMessageBox.warning(self, "Error", "Error 2 \n" + str(e), QMessageBox.Ok)            return 0    #rif biblio    def on_pushButton_insert_row_rif_biblio_pressed(self):        self.insert_new_row('self.tableWidget_rif_biblio')    def on_pushButton_remove_row_rif_biblio_pressed(self):        self.remove_row('self.tableWidget_rif_biblio')    def data_error_check(self):        test = 0        EC = Error_check()        if EC.data_is_empty(str(self.comboBox_site_name.currentText())) == 0:            QMessageBox.warning(self, "Warning", "Site field. \n This field cannot be empty",  QMessageBox.Ok)            test = 1        return test     def check_record_state(self):        ec = self.data_error_check()        if ec == 1:            return 1 #ci sono errori di immissione        elif self.records_equal_check() == 1 and ec == 0:            #self.update_if(QMessageBox.warning(self,'Warning',"The record has been changed. Do you want to save changes?", QMessageBox.Ok|QMessageBox.Cancel))            #self.charge_records()            return 0 #non ci sono errori di immissione    def on_pushButton_view_all_pressed(self):        self.empty_fields()        self.charge_records()        self.fill_fields()        self.BROWSE_STATUS = "b"        self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])        if type(self.REC_CORR) == "<class 'str'>":            corr = 0        else:            corr = self.REC_CORR        self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)        self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0        self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])        # records surf functions    #records surf functions    def on_pushButton_first_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.fill_fields(0)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except:                pass#QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_last_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                self.fill_fields(self.REC_CORR)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except:                pass#QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_prev_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR - 1            if self.REC_CORR == -1:                self.REC_CORR = 0                QMessageBox.warning(self, "Warning", "You are to the first record!", QMessageBox.Ok)                    else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                except:                    pass#QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_next_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR + 1            if self.REC_CORR >= self.REC_TOT:                self.REC_CORR = self.REC_CORR - 1                QMessageBox.warning(self, "Error", "You are to the first record!", QMessageBox.Ok)              else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                except:                    pass#QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_delete_pressed(self):        msg = QMessageBox.warning(self,"Warning!!!","Do you really want to delete the record? \n The action is irreversible", QMessageBox.Ok|QMessageBox.Cancel)        if msg == QMessageBox.Cancel:            QMessageBox.warning(self,"Message!!!","Action cancelled!")        else:            try:                id_to_delete = eval("self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE)                self.DB_MANAGER.delete_one_record(self.TABLE_NAME, self.ID_TABLE, id_to_delete)                self.charge_records() #charge records from DB                QMessageBox.warning(self,"Message!!!","Record deleted!")            except Exception as e:                QMessageBox.warning(self,"Message!!!","Type of Error: "+str(e))            if not bool(self.DATA_LIST):                QMessageBox.warning(self, "Warning", "The database is empty!",  QMessageBox.Ok)                self.DATA_LIST = []                self.DATA_LIST_REC_CORR = []                self.DATA_LIST_REC_TEMP = []                self.REC_CORR = 0                self.REC_TOT = 0                self.empty_fields()                self.set_rec_counter(0, 0)            #check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])    def on_pushButton_new_search_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.enable_button_search(0)            #set the GUI for a new search            if self.BROWSE_STATUS != "f":                self.BROWSE_STATUS = "f"                ###                # self.setComboBoxEnable(["self.comboBox_artefact"], "True")                                # self.setComboBoxEnable(["self.comboBox_site_name"], "True")                                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter('', '')                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.charge_list()                self.empty_fields()    def on_pushButton_showLayer_pressed(self):        """        for sing_us in range(len(self.DATA_LIST)):            sing_layer = [self.DATA_LIST[sing_us]]            self.pyQGIS.charge_vector_layers(sing_layer)        """        sing_layer = [self.DATA_LIST[self.REC_CORR]]        self.pyQGIS.charge_pot_layers(sing_layer)    def on_pushButton_search_go_pressed(self):        if self.BROWSE_STATUS != "f":            QMessageBox.warning(self, "Warning", "To carry out a new search click on the 'new search' button",  QMessageBox.Ok)        else:            #TableWidget            if self.lineEdit_divelog_id.text() != "":                divelog_id = int(self.lineEdit_divelog_id.text())            else:                divelog_id = ""            # if self.lineEdit_dm.text() != "":                # dm = float(self.lineEdit_dm.text())            # else:                # dm = None            # if self.lineEdit_dr.text() != "":                # dr = float(self.lineEdit_dr.text())            # else:                # dr = None            # if self.lineEdit_db.text() != "":                # db = float(self.lineEdit_db.text())            # else:                # db = None            # if self.lineEdit_th.text() != "":                # th = float(self.lineEdit_th.text())            # else:                # th = None            # if self.lineEdit_ph.text() != "":                # ph = float(self.lineEdit_ph.text())            # else:                # ph = None            # if self.lineEdit_bh.text() != "":                # bh = float(self.lineEdit_bh.text())             # else:                # bh = None               # if self.lineEdit_thickmin.text() != "":                # thickmin = float(self.lineEdit_thickmin.text())            # else:                # thickmin = None             # if self.lineEdit_thickmax.text() != "":                # thickmax = float(self.lineEdit_thickmax.text())            # else:                # thickmax = None            if self.comboBox_year.currentText() != "":                anno = int(self.comboBox_year.currentText())            else:                anno = ""            if self.lineEdit_box.text() != "":                box = int(self.lineEdit_box.text())            else:                box = ""                            if self.lineEdit_qty.text() != "":                qty = int(self.lineEdit_qty.text())            else:                qty = ""                search_dict = {            self.TABLE_FIELDS[0]  : divelog_id,                                 #1 - Sito            self.TABLE_FIELDS[1]  : "'"+str(self.comboBox_site_name.currentText())+"'",                              #2 - Area            self.TABLE_FIELDS[2]  : "'"+str(self.lineEdit_date.text())+"'",                                                                                                 #3 - US            self.TABLE_FIELDS[3]  : "'"+str(self.comboBox_artefact.currentText())+"'",                                                                  #4 - Definizione stratigrafica            self.TABLE_FIELDS[4]  : "'"+str(self.comboBox_photo.currentText())+"'",                         #5 - Definizione intepretata            self.TABLE_FIELDS[5]  : "'"+str(self.comboBox_draw.currentText())+"'",                                          #6 - descrizione            self.TABLE_FIELDS[6]  : "'"+str(self.comboBox_ret.currentText())+"'",                                       #7 - interpretazione            self.TABLE_FIELDS[7]  : "'"+str(self.comboBox_inclusions.currentText())+"'",                                #8 - periodo iniziale            self.TABLE_FIELDS[8]  : "'"+str(self.comboBox_percent_inclusion.currentText())+"'",                               #9 - fase iniziale            self.TABLE_FIELDS[9]  : "'"+str(self.comboBox_specific_form.currentText())+"'",                             #10 - periodo finale iniziale            self.TABLE_FIELDS[10] : "'"+str(self.comboBox_form.currentText())+"'",                                #11 - fase finale            self.TABLE_FIELDS[11] : "'"+str(self.comboBox_typology.currentText())+"'",                              #12 - scavato             self.TABLE_FIELDS[12] : "'"+str(self.lineEdit_provenance.text())+"'",                                              #13 - attivita              self.TABLE_FIELDS[13] : "'"+str(self.comboBox_munsell_clay.currentText())+"'",                                                   #14 - anno scavo            self.TABLE_FIELDS[14] : "'"+str(self.comboBox_surf_treatment.currentText())+"'",            self.TABLE_FIELDS[15] : "'"+str(self.comboBox_conservation.currentText())+"'",            self.TABLE_FIELDS[16] : "'"+str(self.lineEdit_depth.text())+"'",#16 - data schedatura            self.TABLE_FIELDS[17] : "'"+str(self.lineEdit_storage_.text())+ "'",            self.TABLE_FIELDS[18] : "'"+str(self.lineEdit_period.text())+ "'",            self.TABLE_FIELDS[19] : "'"+str(self.lineEdit_state.text())+ "'",               #19 - conservazione            self.TABLE_FIELDS[20] : "'"+str(self.comboBox_samples.currentText())+ "'",              self.TABLE_FIELDS[21] : "'"+str(self.comboBox_washed.currentText())+ "'",            self.TABLE_FIELDS[22] : "'"+str(self.lineEdit_dm.text())+ "'",                              #15 - metodo            self.TABLE_FIELDS[23] : "'"+str(self.lineEdit_dr.text())+ "'",            self.TABLE_FIELDS[24] : "'"+str(self.lineEdit_db.text())+ "'",            self.TABLE_FIELDS[25] : "'"+str(self.lineEdit_th.text())+ "'",            self.TABLE_FIELDS[26] : "'"+str(self.lineEdit_ph.text())+ "'",            self.TABLE_FIELDS[27] : "'"+str(self.lineEdit_bh.text())+ "'",            self.TABLE_FIELDS[28] : "'"+str(self.lineEdit_thickmin.text())+ "'",            self.TABLE_FIELDS[29] : "'"+str(self.lineEdit_thickmax.text())+ "'",            self.TABLE_FIELDS[30] : anno,            self.TABLE_FIELDS[31] : box,            self.TABLE_FIELDS[33] : str(self.textEdit_description.toPlainText()),            self.TABLE_FIELDS[34] : "'"+str(self.comboBox_area.currentText())+ "'",            self.TABLE_FIELDS[35] : "'"+str(self.comboBox_munsell_surf.currentText())+ "'",            self.TABLE_FIELDS[36] : "'"+str(self.comboBox_category.currentText())+ "'",            self.TABLE_FIELDS[37] : "'"+str(self.comboBox_wheelmade.currentText())+"'",            self.TABLE_FIELDS[38] : qty            }            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            if not bool(search_dict):                QMessageBox.warning(self, " WARNING", "No search has been set!!!", QMessageBox.Ok)            else:                res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                if not bool(res):                    QMessageBox.warning(self, "WARNING", "No record found!", QMessageBox.Ok)                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields(self.REC_CORR)                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    #self.setComboBoxEnable(["self.comboBox_artefact"], "True")                                        # self.setComboBoxEnable(["self.comboBox_site_name"], "True")                                                        else:                    self.DATA_LIST = []                    for i in res:                        self.DATA_LIST.append(i)                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                    if self.REC_TOT == 1:                        strings = ("It has been found", self.REC_TOT, "record")                        if self.toolButtonGis.isChecked():                            self.pyQGIS.charge_pot_layers(self.DATA_LIST)                    else:                        strings = ("They have been found", self.REC_TOT, "records")                        if self.toolButtonGis.isChecked():                            self.pyQGIS.charge_pot_layers(self.DATA_LIST)                    #self.setComboBoxEnable(["self.comboBox_diver"],"True")                    # self.setComboBoxEnable(["self.comboBox_artefact"], "True")                                        # self.setComboBoxEnable(["self.comboBox_site_name"], "True")                                        QMessageBox.warning(self, "Messaggio", "%s %d %s" % strings, QMessageBox.Ok)        self.enable_button_search(1)                def update_if(self, msg):        rec_corr = self.REC_CORR        if msg == QMessageBox.Ok:            test = self.update_record()            if test == 1:                id_list = []                for i in self.DATA_LIST:                    id_list.append(eval("i." + self.ID_TABLE))                self.DATA_LIST = []                if self.SORT_STATUS == "n":                    temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc',                                                                self.MAPPER_TABLE_CLASS,                                                                self.ID_TABLE)  # self.DB_MANAGER.query_bool(self.SEARCH_DICT_TEMP, self.MAPPER_TABLE_CLASS) #                else:                    temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE,                                                                self.MAPPER_TABLE_CLASS, self.ID_TABLE)                for i in temp_data_list:                    self.DATA_LIST.append(i)                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                if type(self.REC_CORR) == "<type 'str'>":                    corr = 0                else:                    corr = self.REC_CORR                return 1            elif test == 0:                return 0    def update_record(self):        try:            self.DB_MANAGER.update(self.MAPPER_TABLE_CLASS,                                   self.ID_TABLE,                                   [eval("int(self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE + ")")],                                   self.TABLE_FIELDS,                                   self.rec_toupdate())            return 1        except Exception as e:            QMessageBox.warning(self, "Message", "Encoding problem: accents or characters that are not accepted by the database have been inserted. If you close the window without correcting the errors the data will be lost. Create a copy of everything on a seperate word document. Error :" + str(e), QMessageBox.Ok)            return 0    def rec_toupdate(self):        rec_to_update = self.UTILITY.pos_none_in_list(self.DATA_LIST_REC_TEMP)        return rec_to_update        # custom functions    def charge_records(self):        self.DATA_LIST = []        if self.DB_SERVER == 'sqlite':            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                self.DATA_LIST.append(i)        else:            id_list = []            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                id_list.append(eval("i." + self.ID_TABLE))            temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc', self.MAPPER_TABLE_CLASS,                                                        self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)    def datestrfdate(self):        now = date.today()        today = now.strftime("%d-%m-%Y")        return today    def yearstrfdate(self):        now = date.today()        year = now.strftime("%Y")        return year    def table2dict(self, n):        self.tablename = n        row = eval(self.tablename + ".rowCount()")        col = eval(self.tablename + ".columnCount()")        lista = []        for r in range(row):            sub_list = []            for c in range(col):                value = eval(self.tablename + ".item(r,c)")                if value != None:                    sub_list.append(str(value.text()))            if bool(sub_list):                lista.append(sub_list)        return lista    def tableInsertData(self, t, d):        """Set the value into alls Grid"""        self.table_name = t        self.data_list = eval(d)        self.data_list.sort()        # column table count        table_col_count_cmd = "{}.columnCount()".format(self.table_name)        table_col_count = eval(table_col_count_cmd)        # clear table        table_clear_cmd = "{}.clearContents()".format(self.table_name)        eval(table_clear_cmd)        for i in range(table_col_count):            table_rem_row_cmd = "{}.removeRow(int({}))".format(self.table_name, i)            eval(table_rem_row_cmd)            # for i in range(len(self.data_list)):            # self.insert_new_row(self.table_name)        for row in range(len(self.data_list)):            cmd = '{}.insertRow(int({}))'.format(self.table_name, row)            eval(cmd)            for col in range(len(self.data_list[row])):                # item = self.comboBox_site_name.setEditText(self.data_list[0][col]                # item = QTableWidgetItem(self.data_list[row][col])                # TODO SL: evauation of QTableWidget does not work porperly                exec_str = '{}.setItem(int({}),int({}),QTableWidgetItem(self.data_list[row][col]))'.format(self.table_name, row, col)                eval(exec_str)    def insert_new_row(self, table_name):        """insert new row into a table based on table_name"""        cmd = table_name + ".insertRow(0)"        eval(cmd)    def remove_row(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        rowIndex = (rowSelected[0].row())        cmd = ("%s.removeRow(%d)") % (table_name, rowIndex)        eval(cmd)    def empty_fields(self):        biblio_row_count = self.tableWidget_rif_biblio.rowCount()        # decoration_row_count = self.tableWidget_dec.rowCount()        self.lineEdit_divelog_id.clear()        self.comboBox_site_name.setEditText("")        self.lineEdit_date.clear()        self.comboBox_artefact.setEditText("")        self.comboBox_photo.setEditText("")        self.comboBox_draw.setEditText("")        self.comboBox_ret.setEditText("")        self.comboBox_inclusions.setEditText("")        self.comboBox_percent_inclusion.setEditText("")        self.comboBox_specific_form.setEditText("")        self.comboBox_form.setEditText("")        self.comboBox_typology.setEditText("")        self.lineEdit_provenance.clear()        self.comboBox_munsell_clay.setEditText("")        self.comboBox_surf_treatment.setEditText("")        self.comboBox_conservation.setEditText("")        self.lineEdit_depth.clear()        self.lineEdit_storage_.clear()        self.lineEdit_period.clear()        self.lineEdit_state.clear()        self.comboBox_samples.setEditText("")        self.comboBox_washed.setEditText("")        self.lineEdit_dm.clear()        self.lineEdit_dr.clear()        self.lineEdit_db.clear()        self.lineEdit_th.clear()        self.lineEdit_ph.clear()        self.lineEdit_bh.clear()        self.lineEdit_thickmin.clear()        self.lineEdit_thickmax.clear()        self.comboBox_year.setEditText("")        self.lineEdit_box.clear()        self.textEdit_description.clear()        self.comboBox_area.setEditText("")        self.comboBox_munsell_surf.setEditText("")        self.comboBox_category.setEditText("")        self.comboBox_wheelmade.setEditText("")        self.lineEdit_qty.clear()        for i in range(biblio_row_count):            self.tableWidget_rif_biblio.removeRow(0)        self.insert_new_row("self.tableWidget_rif_biblio")        # for i in range(decoration_row_count):            # self.tableWidget_dec.removeRow(0)        # self.insert_new_row("self.tableWidget_dec")    def fill_fields(self, n=0):        self.rec_num = n        #QMessageBox.warning(self, "check fill fields", str(self.rec_num),  QMessageBox.Ok)        try:            self.lineEdit_divelog_id.setText(str(self.DATA_LIST[self.rec_num].divelog_id))  #3 - US            str(self.comboBox_site_name.setEditText(self.DATA_LIST[self.rec_num].site))              str(self.lineEdit_date.setText(self.DATA_LIST[self.rec_num].date_))            str(self.comboBox_artefact.setEditText(self.DATA_LIST[self.rec_num].artefact_id))            str(self.comboBox_photo.setEditText(self.DATA_LIST[self.rec_num].photographed))            str(self.comboBox_draw.setEditText(self.DATA_LIST[self.rec_num].drawing))            str(self.comboBox_ret.setEditText(self.DATA_LIST[self.rec_num].retrieved))            str(self.comboBox_inclusions.setEditText(self.DATA_LIST[self.rec_num].inclusions))            str(self.comboBox_percent_inclusion.setEditText(self.DATA_LIST[self.rec_num].percent_inclusion))            str(self.comboBox_specific_form.setEditText(self.DATA_LIST[self.rec_num].specific_part))            str(self.comboBox_form.setEditText(self.DATA_LIST[self.rec_num].form))            str(self.comboBox_typology.setEditText(self.DATA_LIST[self.rec_num].typology))            str(self.lineEdit_provenance.setText(self.DATA_LIST[self.rec_num].provenance))            str(self.comboBox_munsell_clay.setEditText(self.DATA_LIST[self.rec_num].munsell_clay))            str(self.comboBox_surf_treatment.setEditText(self.DATA_LIST[self.rec_num].surf_treatment))            str(self.comboBox_conservation.setEditText(self.DATA_LIST[self.rec_num].conservation))            str(self.lineEdit_depth.setText(self.DATA_LIST[self.rec_num].depth))            str(self.lineEdit_storage_.setText(self.DATA_LIST[self.rec_num].storage_))            str(self.lineEdit_period.setText(self.DATA_LIST[self.rec_num].period))            str(self.lineEdit_state.setText(self.DATA_LIST[self.rec_num].state))            str(self.comboBox_samples.setEditText(self.DATA_LIST[self.rec_num].samples))            str(self.comboBox_washed.setEditText(self.DATA_LIST[self.rec_num].washed))            str(self.lineEdit_dm.setText(self.DATA_LIST[self.rec_num].dm))            str(self.lineEdit_dr.setText(self.DATA_LIST[self.rec_num].dr))            str(self.lineEdit_db.setText(self.DATA_LIST[self.rec_num].db))            str(self.lineEdit_th.setText(self.DATA_LIST[self.rec_num].th))            str(self.lineEdit_ph.setText(self.DATA_LIST[self.rec_num].ph))            str(self.lineEdit_bh.setText(self.DATA_LIST[self.rec_num].bh))            str(self.lineEdit_thickmin.setText(self.DATA_LIST[self.rec_num].thickmin))            str(self.lineEdit_thickmax.setText(self.DATA_LIST[self.rec_num].thickmax))                        # if self.DATA_LIST[self.rec_num].dm == None:                # str(self.lineEdit_dm.setText(""))            # else:                # self.lineEdit_dm.setText(str(self.DATA_LIST[self.rec_num].dm))            # if self.DATA_LIST[self.rec_num].dr == None:                # str(self.lineEdit_dr.setText(""))            # else:                # self.lineEdit_dr.setText(str(self.DATA_LIST[self.rec_num].dr))            # if self.DATA_LIST[self.rec_num].db == None:                # str(self.lineEdit_db.setText(""))            # else:                # self.lineEdit_db.setText(str(self.DATA_LIST[self.rec_num].db))            # if self.DATA_LIST[self.rec_num].th == None:                # str(self.lineEdit_th.setText(""))            # else:                # self.lineEdit_th.setText(str(self.DATA_LIST[self.rec_num].th))            # if self.DATA_LIST[self.rec_num].ph == None:                # str(self.lineEdit_ph.setText(""))            # else:                # self.lineEdit_ph.setText(str(self.DATA_LIST[self.rec_num].ph))            # if self.DATA_LIST[self.rec_num].bh == None:                # str(self.lineEdit_bh.setText(""))            # else:                # self.lineEdit_bh.setText(str(self.DATA_LIST[self.rec_num].bh))            # if self.DATA_LIST[self.rec_num].thickmin == None:                # str(self.lineEdit_thickmin.setText(""))            # else:                # self.lineEdit_thickmin.setText(str(self.DATA_LIST[self.rec_num].thickmin))            # if self.DATA_LIST[self.rec_num].thickmax == None:                # str(self.lineEdit_thickmax.setText(""))            # else:                # self.lineEdit_thickmax.setText(str(self.DATA_LIST[self.rec_num].thickmax))            self.comboBox_year.setEditText(str(self.DATA_LIST[self.rec_num].years))             self.lineEdit_box.setText(str(self.DATA_LIST[self.rec_num].box))            self.tableInsertData("self.tableWidget_rif_biblio",self.DATA_LIST[self.rec_num].biblio)            str(self.textEdit_description.setText(self.DATA_LIST[self.rec_num].description))            str(self.comboBox_area.setEditText(self.DATA_LIST[self.rec_num].area))            str(self.comboBox_munsell_surf.setEditText(self.DATA_LIST[self.rec_num].munsell_surf))            str(self.comboBox_category.setEditText(self.DATA_LIST[self.rec_num].category))            str(self.comboBox_wheelmade.setEditText(self.DATA_LIST[self.rec_num].wheel_made))            self.lineEdit_qty.setText(str(self.DATA_LIST[self.rec_num].qty))            if self.toolButtonPreviewMedia.isChecked() == True:                self.loadMediaPreview()                self.loadMedialist()        except:            pass#QMessageBox.warning(self, "Errore Fill Fields", str(e),  QMessageBox.Ok)       def set_rec_counter(self, t, c):        self.rec_tot = t        self.rec_corr = c        self.label_rec_tot.setText(str(self.rec_tot))        self.label_rec_corrente.setText(str(self.rec_corr))    def set_LIST_REC_TEMP(self):        biblio= self.table2dict("self.tableWidget_rif_biblio")        # if self.lineEdit_dm.text() == "":            # dm = None        # else:            # dm = self.lineEdit_dm.text        # if self.lineEdit_dr.text() == "":            # dr = None        # else:            # dr = self.lineEdit_dr.text        # if self.lineEdit_db.text() == "":            # db = None        # else:            # db = self.lineEdit_db.text        # if self.lineEdit_th.text() == "":            # th = None        # else:            # th = self.lineEdit_th.text        # if self.lineEdit_ph.text() == "":            # ph = None        # else:            # ph = self.lineEdit_ph.text        # if self.lineEdit_bh.text() == "":            # bh = None        # else:            # bh = self.lineEdit_bh.text        # if self.lineEdit_thickmin.text() == "":            # thickmin = None        # else:            # thickmin = self.lineEdit_thickmin.text        # if self.lineEdit_thickmax.text() == "":            # thickmax = None        # else:            # thickmax = self.lineEdit_thickmax.text         #biblio = self.table2dict("self.tableWidget_rif_biblio")        # decoration = self.table2dict("self.tableWidget_dec")        self.DATA_LIST_REC_TEMP = [        str(self.lineEdit_divelog_id.text()),   #3 - US        str(self.comboBox_site_name.currentText()),                      #1 - Sito        str(self.lineEdit_date.text()),        str(self.comboBox_artefact.currentText()),        str(self.comboBox_photo.currentText()),        str(self.comboBox_draw.currentText()),        str(self.comboBox_ret.currentText()),        str(self.comboBox_inclusions.currentText()),        str(self.comboBox_percent_inclusion.currentText()),        str(self.comboBox_specific_form.currentText()),        str(self.comboBox_form.currentText()),        str(self.comboBox_typology.currentText()),        str(self.lineEdit_provenance.text()),        str(self.comboBox_munsell_clay.currentText()),        str(self.comboBox_surf_treatment.currentText()),        str(self.comboBox_conservation.currentText()),        str(self.lineEdit_depth.text()),        str(self.lineEdit_storage_.text()),        str(self.lineEdit_period.text()),        str(self.lineEdit_state.text()),        str(self.comboBox_samples.currentText()),        str(self.comboBox_washed.currentText()),        str(self.lineEdit_dm.text()),        str(self.lineEdit_dr.text()),        str(self.lineEdit_db.text()),        str(self.lineEdit_th.text()),        str(self.lineEdit_ph.text()),        str(self.lineEdit_bh.text()),        str(self.lineEdit_thickmin.text()),        str(self.lineEdit_thickmax.text()),        str(self.comboBox_year.currentText()),        str(self.lineEdit_box.text()),          str(biblio),        str(self.textEdit_description.toPlainText()),        str(self.comboBox_area.currentText()),        str(self.comboBox_munsell_surf.currentText()),        str(self.comboBox_category.currentText()),        str(self.comboBox_wheelmade.currentText()),        str(self.lineEdit_qty.text())        ]    def set_LIST_REC_CORR(self):        self.DATA_LIST_REC_CORR = []        for i in self.TABLE_FIELDS:            self.DATA_LIST_REC_CORR.append(eval("str(self.DATA_LIST[self.REC_CORR]." + i + ")"))    def records_equal_check(self):        self.set_LIST_REC_TEMP()        self.set_LIST_REC_CORR()        #QMessageBox.warning(self, "Error", str(self.DATA_LIST_REC_CORR) + str(self.DATA_LIST_REC_TEMP),  QMessageBox.Ok)        if self.DATA_LIST_REC_CORR == self.DATA_LIST_REC_TEMP:            return 0        else:            return 1    def setComboBoxEditable(self, f, n):        field_names = f        value = n        for fn in field_names:            cmd = ('%s%s%d%s') % (fn, '.setEditable(', n, ')')            eval(cmd)    def setComboBoxEnable(self, f, v):        field_names = f        value = v        for fn in field_names:            cmd = ('%s%s%s%s') % (fn, '.setEnabled(', v, ')')            eval(cmd)    def setTableEnable(self, t, v):        tab_names = t        value = v        for tn in tab_names:            cmd = ('%s%s%s%s') % (tn, '.setEnabled(', v, ')')            eval(cmd)    def testing(self, name_file, message):        f = open(str(name_file), 'w')        f.write(str(message))        f.close()                                    # def on_pushButton_go_to_scheda_pressed(self):        # if self.L=='it':            # QMessageBox.warning(self, "ATTENZIONE", "Se hai modificato il record e non lo hai salvato perderai il dato. Salvare?", QMessageBox.Ok | QMessageBox.Cancel)        # else:            # QMessageBox.warning(self, "Warning", "If you changed the record and didn't save it, you'll lose the record. Do you want save it?", QMessageBox.Ok | QMessageBox.Cancel)                # try:            # table_name = "self.tableWidget_foto"            # rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            # rowSelected = eval(rowSelected_cmd)            # rowIndex = (rowSelected[0].row())            # site = str(self.comboBox_site_name.currentText())            # area = str(self.comboBox_area.currentText())            # us_item = self.tableWidget_foto.item(rowIndex, 2)            # artefact_id = str(us_item.text())            # search_dict = {                           # 'artefact_id':  "'" + str(artefact_id) + "'"}            # u = Utility()            # search_dict = u.remove_empty_items_fr_dict(search_dict)            # res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                        # if not bool(res):                                # if self.L=='it':                    # QMessageBox.warning(self, "ATTENZIONE", "Non e' stato trovato alcun record!", QMessageBox.Ok)                # elif self.L=='de':                    # QMessageBox.warning(self, "ACHTUNG", "kein Eintrag gefunden!", QMessageBox.Ok)                # else:                    # QMessageBox.warning(self, "Warning", "The record has not been found ", QMessageBox.Ok)                # self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                # self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                # self.fill_fields(self.REC_CORR)                # self.BROWSE_STATUS = "b"                # self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                # self.setComboBoxEnable(["self.comboBox_site_name"], "False")                # self.setComboBoxEnable(["self.comboBox_area"], "False")                # self.setComboBoxEnable(["self.comboBox_artefact"], "False")            # else:                # self.empty_fields()                # self.DATA_LIST = []                # for i in res:                    # self.DATA_LIST.append(i)                # self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                # self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                # self.fill_fields()                # self.BROWSE_STATUS = "b"                # self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                # self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                # if self.REC_TOT == 1:                                                            # if self.L=='it':                        # strings = ("E' stato trovato", self.REC_TOT, "record")                    # elif self.L=='de':                        # strings = ("Es wurde gefunden", self.REC_TOT, "record")                    # else:                        # strings = ("has been found", self.REC_TOT, "record")                    # if self.toolButtonGis.isChecked():                        # self.pyQGIS.charge_vector_layers(self.DATA_LIST)                # else:                                        # if self.L=='it':                        # strings = ("Sono stati trovati", self.REC_TOT, "records")                    # elif self.L=='de':                        # strings = ("Sie wurden gefunden", self.REC_TOT, "records")                    # else:                        # strings = ("Have been found", self.REC_TOT, "records")                    # if self.toolButtonGis.isChecked():                        # self.pyQGIS.charge_vector_layers(self.DATA_LIST)                # self.setComboBoxEnable(["self.comboBox_site_name"], "False")                # self.setComboBoxEnable(["self.comboBox_area"], "False")                # self.setComboBoxEnable(["self.comboBox_artefact"], "False")        # except Exception as e:            # e = str(e)            # if self.L=='it':                # QMessageBox.warning(self, "Alert", "Non hai selezionato nessuna riga. Errore python: %s " % (str(e)),                                # QMessageBox.Ok)            # elif self.L=='de':                # QMessageBox.warning(self, "ACHTUNG", "Keine Spalte ausgewält. Error python: %s " % (str(e)),                                # QMessageBox.Ok)            # else:                # QMessageBox.warning(self, "Alert", "You didn't select any row. Python error: %s " % (str(e)),                                # QMessageBox.Ok)              def generate_list_pdf2(self):        data_list = []        for i in range(len(self.DATA_LIST)):            data_list.append([            str(self.DATA_LIST[i].divelog_id),                                  #1 - Sito            str(self.DATA_LIST[i].artefact_id),                                 #2 -             str(self.DATA_LIST[i].years)            ])        return data_list        def generate_list_foto(self):        data_list_foto = []        for i in range(len(self.DATA_LIST)):                            conn = Connection()                                    thumb_path = conn.thumb_path()            thumb_path_str = thumb_path['thumb_path']                                    search_dict = {'id_entity': "'"+ str(eval("self.DATA_LIST[i].id_rep"))+"'", 'entity_type' : "'POTTERY'"}                        record_doc_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIAVIEW')                                         for e in record_doc_list:                            thumbnail = (thumb_path_str+e.filepath)                foto= (e.id_media)                              data_list_foto.append([                    str(self.DATA_LIST[i].site),                                    #1 - Sito                    str(self.DATA_LIST[i].area),                    str(self.DATA_LIST[i].artefact_id),                                  #2 -                     str(self.DATA_LIST[i].description),                    str(foto),#5                    str(thumbnail)])#6                    return data_list_foto                                    # #####################fine########################    def generate_list_pdf(self):        data_list = []        for i in range(len(self.DATA_LIST)):            data_list.append([            str(self.DATA_LIST[i].divelog_id),                                              str(self.DATA_LIST[i].artefact_id),            str(self.DATA_LIST[i].site),                str(self.DATA_LIST[i].area),                str(self.DATA_LIST[i].inclusions),              str(self.DATA_LIST[i].form),              str(self.DATA_LIST[i].specific_part),               str(self.DATA_LIST[i].category),            str(self.DATA_LIST[i].typology),                str(self.DATA_LIST[i].depth),               str(self.DATA_LIST[i].retrieved),               str(self.DATA_LIST[i].percent_inclusion),             str(self.DATA_LIST[i].provenance),             str(self.DATA_LIST[i].munsell_clay),             str(self.DATA_LIST[i].munsell_surf),            str(self.DATA_LIST[i].surf_treatment),            str(self.DATA_LIST[i].conservation),               str(self.DATA_LIST[i].storage_),                str(self.DATA_LIST[i].period),              str(self.DATA_LIST[i].state),               str(self.DATA_LIST[i].samples),             str(self.DATA_LIST[i].washed),              str(self.DATA_LIST[i].dm),              str(self.DATA_LIST[i].dr),              str(self.DATA_LIST[i].db),              str(self.DATA_LIST[i].th),              str(self.DATA_LIST[i].ph),              str(self.DATA_LIST[i].bh),              str(self.DATA_LIST[i].thickmin),                str(self.DATA_LIST[i].thickmax),                str(self.DATA_LIST[i].date_),               str(self.DATA_LIST[i].years),            str(self.DATA_LIST[i].description),            str(self.DATA_LIST[i].photographed),             str(self.DATA_LIST[i].drawing),            str(self.DATA_LIST[i].wheel_made)         ])        return data_list        def on_pushButton_print_pressed(self):                       if self.checkBox_s_pottery.isChecked():            pottery_pdf_sheet = generate_POTTERY_pdf()            data_list = self.generate_list_pdf()            pottery_pdf_sheet.build_POTTERY_sheets(data_list)            QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)        else:               pass            if self.checkBox_e_pottery.isChecked() :            POTTERY_index_pdf = generate_POTTERY_pdf()            data_list = self.generate_list_pdf2()                        try:                               if bool(data_list):                    POTTERY_index_pdf.build_index_POTTERY(data_list, data_list[0][0])                     QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                else:                    QMessageBox.warning(self, 'Warning',"Pottery list  can't to be exported, you must fill before the form",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)        else:            pass            if self.checkBox_e_foto_t.isChecked():            POTTERY_index_pdf = generate_POTTERY_pdf()            data_list_foto = self.generate_list_foto()                try:                    if bool(data_list_foto):                        POTTERY_index_pdf.build_index_Foto(data_list_foto, data_list_foto[0][0])                        QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                                                       else:                        QMessageBox.warning(self, 'Warning',"Pottery list photo can't to be exported, you must tag before the pics",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)                if self.checkBox_e_foto.isChecked():            POTTERY_index_pdf = generate_POTTERY_pdf()            data_list_foto = self.generate_list_foto()                try:                    if bool(data_list_foto):                        POTTERY_index_pdf.build_index_Foto_2(data_list_foto, data_list_foto[0][0])                        QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                                                       else:                        QMessageBox.warning(self, 'Warniong',"Pottery list photo can't to be exported because the image are not tagged",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)    def loadMediaPreview(self, mode = 0):        self.iconListWidget.clear()        conn = Connection()                thumb_path = conn.thumb_path()        thumb_path_str = thumb_path['thumb_path']                if mode == 0:            """ if has geometry column load to map canvas """            rec_list =  self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            search_dict = {'id_entity'  : "'"+str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))+"'", 'entity_type' : "'POTTERY'"}            record_us_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')            for i in record_us_list:                search_dict = {'id_media' : "'"+str(i.id_media)+"'"}                u = Utility()                search_dict = u.remove_empty_items_fr_dict(search_dict)                mediathumb_data = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                thumb_path = str(mediathumb_data[0].filepath)                item = QListWidgetItem(str(i.media_name))                item.setData(Qt.UserRole,str(i.media_name))                icon = QIcon(thumb_path_str+thumb_path)                item.setIcon(icon)                self.iconListWidget.addItem(item)        elif mode == 1:            self.iconListWidget.clear()    def openWide_image(self):        items = self.iconListWidget.selectedItems()        conn = Connection()        conn_str = conn.conn_str()        thumb_resize = conn.thumb_resize()        thumb_resize_str = thumb_resize['thumb_resize']        for item in items:            dlg = ImageViewer()            id_orig_item = item.text()  # return the name of original file            search_dict = {'media_filename': "'" + str(id_orig_item) + "'", 'mediatype': "'" + 'video' + "'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)                        res = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                                    search_dict_2 = {'media_filename': "'" + str(id_orig_item) + "'", 'mediatype': "'" + 'image' + "'"}                        search_dict_2 = u.remove_empty_items_fr_dict(search_dict_2)                        res_2 = self.DB_MANAGER.query_bool(search_dict_2, "MEDIA_THUMB")                        search_dict_3 = {'media_filename': "'" + str(id_orig_item) + "'"}                          search_dict_3 = u.remove_empty_items_fr_dict(search_dict_3)                        res_3 = self.DB_MANAGER.query_bool(search_dict_3, "MEDIA_THUMB")                        file_path_3 = str(res_3[0].path_resize)            if bool(res):                            os.startfile(str(thumb_resize_str+file_path_3))            else:                pass            if bool(res_2):                dlg.show_image(str(thumb_resize_str+file_path_3))                  dlg.exec_()            else:                pass    # def on_pottery_form_pressed(self):        # pottery_pdf_sheet = generate_POTTERY_pdf()        # data_list = self.generate_list_pdf()        # pottery_pdf_sheet.build_POTTERY_sheets(data_list)       # def on_pottery_list_pressed(self):        # POTTERY_index_pdf = generate_POTTERY_pdf()        # data_list = self.generate_list_pdf2()        # POTTERY_index_pdf.build_index_POTTERY(data_list, data_list[0][0])       def on_pushButton_open_dir_pressed(self):        HOME = os.environ['HFF_HOME']        path = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])