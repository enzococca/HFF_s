#! /usr/bin/env python# -*- coding: utf 8 -*-"""/***************************************************************************        HFF_system Plugin  - A QGIS plugin to manage archaeological dataset                             stored in Postgres                             -------------------    begin                : 2007-12-01    copyright            : (C) 2008 by Luca Mandolesi    email                : mandoluca at gmail.com ***************************************************************************//*************************************************************************** *                                                                          * *   This program is free software; you can redistribute it and/or modify   * *   it under the terms of the GNU General Public License as published by   * *   the Free Software Foundation; either version 2 of the License, or      * *   (at your option) any later version.                                    *                                                                       * ***************************************************************************/"""from __future__ import absolute_importimport osfrom datetime import dateimport sysimport reimport platformfrom pdf2docx import parsefrom builtins import rangefrom builtins import strfrom datetime import datefrom qgis.core import QgsSettingsfrom qgis.PyQt.QtCore import *from qgis.PyQt.QtGui import QColor, QIconfrom qgis.PyQt.QtWidgets import *from qgis.PyQt.uic import loadUiTypefrom qgis.PyQt.QtSql import QSqlDatabase, QSqlTableModel# --import HFF_system modules--#from ..modules.db.hff_system__conn_strings import Connectionfrom ..modules.db.hff_db_manager import Hff_db_managementfrom ..modules.db.hff_system__utility import Utilityfrom ..modules.gis.hff_system__pyqgis import Hff_pyqgisfrom ..modules.utility.delegateComboBox import ComboBoxDelegatefrom ..modules.utility.hff_system__error_check import Error_checkfrom ..modules.utility.hff_system__exp_USsheet_pdf import *from ..modules.utility.hff_system__print_utility import Print_utilityfrom ..gui.imageViewer import ImageViewerfrom ..gui.sortpanelmain import SortPanelMainfrom elasticsearch import Elasticsearches = Elasticsearch()MAIN_DIALOG_CLASS, _ = loadUiType(    os.path.join(os.path.dirname(__file__), os.pardir, 'gui', 'ui', 'hff_system__UW_ui.ui'))class hff_system__UW(QDialog, MAIN_DIALOG_CLASS):    L=QgsSettings().value("locale/userLocale")[0:2]    MSG_BOX_TITLE = "HFF - UW form"    DATA_LIST = []    DATA_LIST_REC_CORR = []    DATA_LIST_REC_TEMP = []    REC_CORR = 0    REC_TOT = 0    STATUS_ITEMS = {"b": "Current", "f": "Find", "n": "New Record"}    BROWSE_STATUS = "b"    SORT_MODE = 'asc'    SORTED_ITEMS = {"n": "Not sorted", "o": "Sorted"}    SORT_STATUS = "n"    HOME = os.environ['HFF_HOME']    PDFFOLDER = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")    UTILITY = Utility()    DB_MANAGER = ""    TABLE_NAME = 'dive_log'    MAPPER_TABLE_CLASS = "UW"    NOME_SCHEDA = "UW Form"    ID_TABLE = "id_dive"    ID_SITO = 'site'    CONVERSION_DICT = {        ID_TABLE: ID_TABLE,        "Divelog ID": "divelog_id",        "Area reference": "area_id",        "Diver 1": "diver_1",        "Diver 2": "diver_2",        "Additional diver": "additional_diver",        "Standby diver": "standby_diver",        "Task": "task",        "Result": "result",        "Dive Supervisor": "dive_supervisor",        "Bar start Diver 1": "bar_start_diver1",        "Bar end Diver 1": "bar_end_diver1",        "UW Temperature": "uw_temperature",        "UW Visibility": "uw_visibility",        "UW Current": "uw_current_",        "Wind": "wind",        "Breathing mix": "breathing_mix",        "Max depth": "max_depth",        "Surface interval": "surface_interval",        "Comments": "comments_",        "Bottom time": "bottom_time",        "N photo": "photo_nbr",        "N video": "video_nbr",        "Camera": "camera",        "Time in": "time_in",        "Time out": "time_out",        "Date": "date_",        "YEAR": "years",        "DP Diver 1": "dp_diver1",        "Photo": "photo_id",        "Video": "video_id",        "Site": "site",        "Layer": "layer",        "Bar start Diver 2": "bar_start_diver2",        "Bar end Diver 2": "bar_end_diver2",        "DP Diver 2": "dp_diver2",    }    SORT_ITEMS = [        ID_TABLE,        "Divelog ID",        "Area reference",        "Diver 1",        "Diver 2",        "Additional diver",        "Standby diver",        "Task",        "Result",        "Dive Supervisor",        "Bar start Diver 1",        "Bar end Diver 1",        "UW Temperature",        "UW Visibility",        "UW Current",        "Wind",        "Breathing mix",        "Max depth",        "Surface interval",        "Comments",        "Bottom time",        "N photo",        "N video",        "Camera",        "Time in",        "Time out",        "Date",        "YEAR",        "Dp Diver 1",        "Photo",        "Video",        "Site",        "Layer",        "Bar start Diver 2",        "Bar end Diver 2",        "DP Diver 2",    ]    QUANT_ITEMS = [        'Divelog ID',        'Area reference',        'Diver 1',        'Diver 2',        'Additional diver',        'Standby diver',        'Dive Supervisor',        'UW Temperature',        'UW Visibility',        'UW Current',        'Wind',        'Breathing mix',        'Max depth',        'Surface interval',        'Comments',        'Bottom time',        'N photo',        'N video',        'Camera of',        'Time in',        'Time out',        'Date',        'YEAR'    ]    TABLE_FIELDS_UPDATE = [        "divelog_id",        "area_id",        "diver_1",        "diver_2",        "additional_diver",        "standby_diver",        "task",        "result",        "dive_supervisor",        "bar_start_diver1",        "bar_end_diver1",        "uw_temperature",        "uw_visibility",        "uw_current_",        "wind",        "breathing_mix",        "max_depth",        "surface_interval",        "comments_",        "bottom_time",        "photo_nbr",        "video_nbr",        "camera",        "time_in",        "time_out",        "date_",        "years",        "dp_diver1",        "photo_id",        "video_id",        "site",        "layer",        "bar_start_diver2",        "bar_end_diver2",        "dp_diver2"    ]    TABLE_FIELDS = [        'divelog_id',        'area_id',        'diver_1',        'diver_2',        'additional_diver',        'standby_diver',        'task',        'result',        'dive_supervisor',        'bar_start_diver1',        'bar_end_diver1',        'uw_temperature',        'uw_visibility',        'uw_current_',        'wind',        'breathing_mix',        'max_depth',        'surface_interval',        'comments_',        'bottom_time',        'photo_nbr',        'video_nbr',        'camera',        'time_in',        'time_out',        'date_',        'years',        'dp_diver1',        'photo_id',        'video_id',        'site',        'layer',        'bar_start_diver2',        'bar_end_diver2',        'dp_diver2'    ]            DB_SERVER = "not defined"  ####nuovo sistema sort    def __init__(self, iface):        super().__init__()        self.iface = iface        self.pyQGIS = Hff_pyqgis(iface)        self.setupUi(self)        self.mDockWidget_3.setHidden(True)        self.mDockWidget_4.setHidden(True)        self.currentLayerId = None        self.HOME = os.environ['HFF_HOME']        try:            self.on_pushButton_connect_pressed()        except Exception as e:            QMessageBox.warning(self, "Connection system", str(e), QMessageBox.Ok)        site = self.comboBox_site.currentText()        self.comboBox_site.setEditText(site)        self.empty_fields()        self.fill_fields()        self.search_1.textChanged.connect(self.update_filter)        self.checkBox_query.update()        self.checkBox_query.stateChanged.connect(self.listview_us)###anche questo        self.toolButton_pdfpath.clicked.connect(self.setPathpdf)        self.pbnOpenpdfDirectory.clicked.connect(self.openpdfDir)        self.customize_GUI()        self.comboBox_uwcurrents.completer().setCompletionMode(QCompleter.PopupCompletion)    def enable_button(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_new_search.setEnabled(n)        self.pushButton_search_go.setEnabled(n)        self.pushButton_sort.setEnabled(n)    def enable_button_search(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_save.setEnabled(n)        self.pushButton_sort.setEnabled(n)        self.pushButton_sort.setEnabled(n)        # self.pushButton_insert_row_photo.setEnabled(n)        # self.pushButton_remove_row_photo.setEnabled(n)        # self.pushButton_insert_row_video.setEnabled(n)        # self.pushButton_remove_row_video.setEnabled(n)        def setPathpdf(self):        s = QgsSettings()        dbpath = QFileDialog.getOpenFileName(            self,            "Set file name",            self.PDFFOLDER,            " PDF (*.pdf)"        )[0]        #filename=dbpath.split("/")[-1]        if dbpath:            self.lineEdit_pdf_path.setText(dbpath)            s.setValue('',dbpath)     def openpdfDir(self):        HOME = os.environ['HFF_HOME']        path = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])        def on_pushButton_convert_pressed(self):        # if not bool(self.setPathpdf()):                # QMessageBox.warning(self, "INFO", "devi scegliere un file pdf",                                # QMessageBox.Ok)        try:            pdf_file = self.lineEdit_pdf_path.text()            filename=pdf_file.split("/")[-1]            docx_file = self.PDFFOLDER+'/'+filename+'.docx'            # convert pdf to docx            parse(pdf_file, docx_file, start=self.lineEdit_pag1.text(), end=self.lineEdit_pag2.text())                        QMessageBox.information(self, "INFO", "Conversion completed",                                QMessageBox.Ok)        except Exception as e:            QMessageBox.warning(self, "Error", str(e),                                QMessageBox.Ok)        def on_pushButton_connect_pressed(self):        """This method establishes a connection between GUI and database"""        conn = Connection()        conn_str = conn.conn_str()        test_conn = conn_str.find('sqlite')        if test_conn == 0:            self.DB_SERVER = "sqlite"        try:            self.DB_MANAGER = Hff_db_management(conn_str)            self.DB_MANAGER.connection()            self.charge_records()  # charge records from DB            # check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = 'b'                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()                # QMessageBox.warning(self,"Dey's sentence", "Hey Jack keep in mind:"  + " it was better to die from an early age with ass hairs to balls than to die from great soldiers with burnt ass hairs!",                                    # QMessageBox.Ok)                        else:                QMessageBox.warning(self,"WELCOME HFF user", "Welcome in HFF survey:" + " Divlog form." + " The DB is empty. Push 'Ok' and Good Work!",                                    QMessageBox.Ok)                self.charge_list()                self.BROWSE_STATUS = 'x'                self.on_pushButton_new_rec_pressed()        except Exception as e:            e = str(e)            if e.find("no such table"):                msg = "The connection failed {}. " \                      "You MUST RESTART QGIS or bug detected! Report it to the developer".format(str(e))            else:                msg = "Warning bug detected! Report it to the developer. Error: ".format(str(e))                self.iface.messageBar().pushMessage(self.tr(msg), Qgis.Warning, 0)    def charge_list(self):        # lista area reference                site_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('site_table', 'location_', 'SITE'))        try:                site_vl.remove('')        except:            pass           self.comboBox_site.clear()        site_vl.sort()        self.comboBox_site.addItems(site_vl)        #area        area_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'area_id', 'UW'))        try:            area_vl.remove('')        except:            pass        self.comboBox_area_reference.clear()        area_vl.sort()        self.comboBox_area_reference.addItems(area_vl)                        # #lista years reference        anno = ['2013', '2014', '2015', '2016', '2017', '2018',                '2019', '2020', '2021','2022','2023']        self.comboBox_years.clear()        self.comboBox_years.addItems(anno)                                diver_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'diver_1', 'UW'))        try:            diver_vl.remove('')        except:            pass        self.comboBox_diver.clear()        diver_vl.sort()        self.comboBox_diver.addItems(diver_vl)        # lista diver reference        buddy_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'diver_2', 'UW'))        try:            buddy_vl.remove('')        except:            pass        self.comboBox_buddy.clear()        buddy_vl.sort()        self.comboBox_buddy.addItems(buddy_vl)                add_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'additional_diver', 'UW'))        try:            add_vl.remove('')        except:            pass        self.comboBox_add_diver.clear()        add_vl.sort()        self.comboBox_add_diver.addItems(add_vl)                stdiver_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'standby_diver', 'UW'))        try:            stdiver_vl.remove('')        except:            pass        self.comboBox_standby_diver.clear()        stdiver_vl.sort()        self.comboBox_standby_diver.addItems(stdiver_vl)                        supervisor = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'dive_supervisor', 'UW'))        try:            supervisor.remove('')        except:            pass        self.comboBox_supervisor.clear()        supervisor.sort()        self.comboBox_supervisor.addItems(supervisor)                wind2_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('dive_log', 'wind', 'UW'))        try:            wind2_vl.remove('')        except:            pass        self.comboBox_wind.clear()        wind2_vl.sort()        self.comboBox_wind.addItems(wind2_vl)            def customize_GUI(self):        # self.tableWidget_foto.setColumnWidth(0, 100)        # self.tableWidget_foto.setColumnWidth(1, 100)        # self.tableWidget_foto.setColumnWidth(2, 100)        # self.tableWidget_foto.setColumnWidth(3, 100)        # self.tableWidget_foto.setColumnWidth(4, 200)        self.iconListWidget.setLineWidth(2)        self.iconListWidget.setMidLineWidth(2)        self.iconListWidget.setProperty("showDropIndicator", False)        self.iconListWidget.setIconSize(QSize(200, 200))        self.iconListWidget.setMovement(QListView.Snap)        self.iconListWidget.setResizeMode(QListView.Adjust)        self.iconListWidget.setLayoutMode(QListView.Batched)        self.iconListWidget.setUniformItemSizes(True)        self.iconListWidget.setObjectName("iconListWidget")        self.iconListWidget.SelectionMode()        self.iconListWidget.setSelectionMode(QAbstractItemView.SingleSelection)        self.iconListWidget.itemDoubleClicked.connect(self.openWide_image)                self.iconListWidget_2.setLineWidth(2)        self.iconListWidget_2.setMidLineWidth(2)        self.iconListWidget_2.setProperty("showDropIndicator", False)        self.iconListWidget_2.setIconSize(QSize(430, 570))        self.iconListWidget_2.setMovement(QListView.Snap)        self.iconListWidget_2.setResizeMode(QListView.Adjust)        self.iconListWidget_2.setLayoutMode(QListView.Batched)        self.iconListWidget_2.setUniformItemSizes(True)        self.iconListWidget_2.setObjectName("iconListWidget_2")        self.iconListWidget_2.SelectionMode()        self.iconListWidget_2.setSelectionMode(QAbstractItemView.SingleSelection)        self.iconListWidget_2.itemDoubleClicked.connect(self.openWide_image)        # def loadMedialist(self):        # self.tableWidget_foto.clear()        # col =['Site','Area','Year','Divelog ID']        # self.tableWidget_foto.setHorizontalHeaderLabels(col)        # numRows = self.tableWidget_foto.setRowCount(1000)        # try:             # search_dict = {                # 'site': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]. " + self.ID_SITO)) + "'"}            # record_us_list = self.DB_MANAGER.query_bool(search_dict, 'UW')            # nus=0            # for b in record_us_list:                # if nus== 0:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.site)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.area_id)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.divelog_id)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.years)))                        # nus+=1                # else:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.site)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.area_id)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.divelog_id)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.years)))                        # nus+=1         # except:            # pass    def listview_us(self):        if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()            conn_sqlite = conn.databasename()            conn_user = conn.datauser()            conn_host = conn.datahost()            conn_port = conn.dataport()            port_int  = conn_port["port"]            port_int.replace("'", "")            conn_password = conn.datapassword()            #sito_set= conn.sito_set()            #sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            if test_conn == 0:                sqlite_DB_path = '{}{}{}'.format(self.HOME, os.sep,                                               "HFF_DB_folder")                 db = QSqlDatabase("QSQLITE")                 db.setDatabaseName(sqlite_DB_path +os.sep+ conn_sqlite["db_name"])                db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                 self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                column_titles = {                     "site":"SITE",                    "divleog_id": "DIVELOG ID",                     "years": "YEAR"}                 for n, t in column_titles.items():                     idx = self.model_a.fieldIndex( n)                     self.model_a.setHeaderData( idx, Qt.Horizontal, t)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                 # else:                self.model_a.select()             else:                db = QSqlDatabase.addDatabase("QPSQL")                db.setHostName(conn_host["host"])                db.setDatabaseName(conn_sqlite["db_name"])                db.setPort(int(port_int))                db.setUserName(conn_user['user'])                db.setPassword(conn_password['password'])                 db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                # else:                self.model_a.select()         else:            self.checkBox_query.setChecked(False)    def submit(self):        if self.checkBox_query.isChecked():            self.model_a.database().transaction()            if self.model_a.submitAll():                self.model_a.database().commit()                if self.L=='it':                    QMessageBox.information(self, "Record",  "record salvato")                elif self.L=='de':                    QMessageBox.information(self, "Datensatz",  "Datensatz gespeichert")                else:                    QMessageBox.information(self, "Record",  "record saved")                        else:                self.model_a.database().rollback()                if self.L=='it':                    QMessageBox.warning(self, "Cached Table",                            "Il db ha segnalato un errore: %s" % self.model_a.lastError().text())                            elif self.L=='de':                    QMessageBox.warning(self, "Cached Table",                            "Die Datenbank meldete einen Fehler: %s" % self.model_a.lastError().text())                                                else:                    QMessageBox.warning(self, "Cached Table",                            "The database reported an error: %s" % self.model_a.lastError().text())                                else:                self.checkBox_query.setChecked(False)    def update_filter(self, s):         if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()                # sito_set= conn.sito_set()            # sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            s_field = self.field.currentText()            s = re.sub("[\W_] +", "", s)            if test_conn == 0:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                         # self.model_a.setFilter(filter_str)                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     self.model_a.setFilter(filter_str)                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)            else:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                        # if bool(filter_str):                            # self.model_a.setFilter(filter_str)                            # self.model_a.select()                        # else:                            # pass                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     if bool(filter_str):                        self.model_a.setFilter(filter_str)                        self.model_a.select()                     else:                        pass                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)        else:                self.checkBox_query.setChecked(False)        def on_pushButton_go_to_scheda_pressed(self):        if self.L=='it':            QMessageBox.warning(self, "ATTENZIONE", "Se hai modificato il record e non lo hai salvato perderai il dato. Salvare?", QMessageBox.Ok | QMessageBox.Cancel)        else:            QMessageBox.warning(self, "Warning", "If you changed the record and didn't save it, you'll lose the record. Do you want save it?", QMessageBox.Ok | QMessageBox.Cancel)                        try:            #table_name = "self.table"            #rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            rowSelected = self.table.currentIndex()#eval(rowSelected_cmd)            rowIndex = rowSelected.row()            sito_item = self.table.model().index(rowIndex,31)            area_item = self.table.model().index(rowIndex,0)            #us = str(self.lineEdit_us.text())            us_item = self.table.model().index(rowIndex,27)            #for i in us_item:            sito =self.table.model().data(sito_item)            divelog_id= self.table.model().data(area_item)            years = self.table.model().data(us_item)            search_dict = {'site': "'" + str(sito) + "'",                           'divelog_id': "'" + str(divelog_id) + "'",                           'years': years}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)            self.empty_fields()            self.DATA_LIST = []            for i in res:                self.DATA_LIST.append(i)            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.fill_fields()            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)        except Exception as e:            e = str(e)            if self.L=='it':                QMessageBox.warning(self, "Alert", "Non hai selezionato nessuna riga. Errore python: %s " % (str(e)),                                QMessageBox.Ok)            elif self.L=='de':                QMessageBox.warning(self, "ACHTUNG", "Keine Spalte ausgew√§lt. Error python: %s " % (str(e)),                                QMessageBox.Ok)            else:                QMessageBox.warning(self, "Alert", "You didn't select any row. Python error: %s " % (str(e)),                                QMessageBox.Ok)     def on_toolButtonPreviewMedia_toggled(self):        if self.toolButtonPreviewMedia.isChecked() == True:            QMessageBox.warning(self, "Message",                                "Preview Media Dive Log actived. The image can be visualaized in media section",                                QMessageBox.Ok)            self.loadMediaPreview()            self.loadMediaPreview_2()                    else:            self.loadMediaPreview(1)            self.loadMediaPreview_2(1)                                 def loadMediaPreview(self, mode=0):        self.iconListWidget.clear()        conn = Connection()                thumb_path = conn.thumb_path()        thumb_path_str = thumb_path['thumb_path']                                if mode == 0:            """ if has geometry column load to map canvas """            rec_list = self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            search_dict = {'id_entity': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE)) + "'",                           'entity_type': "'DOC'"}            record_doc_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')            for i in record_doc_list:                search_dict = {'id_media': "'" + str(i.id_media) + "'"}                u = Utility()                search_dict = u.remove_empty_items_fr_dict(search_dict)                mediathumb_data = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                thumb_path = str(mediathumb_data[0].filepath)                item = QListWidgetItem(str(i.media_name))                item.setData(Qt.UserRole, str(i.media_name))                icon = QIcon(thumb_path_str+thumb_path)                item.setIcon(icon)                self.iconListWidget.addItem(item)        elif mode == 1:            self.iconListWidget.clear()    def loadMediaPreview_2(self, mode=0):        self.iconListWidget_2.clear()                conn = Connection()                thumb_path = conn.thumb_path()        thumb_path_str = thumb_path['thumb_path']        if mode == 0:            """ if has geometry column load to map canvas """            pe_list = self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            search_dict = {'id_entity': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE)) + "'",                             'entity_type': "'PE'"}            record_pe_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')            for i in record_pe_list:                search_dict = {'id_media': "'" + str(i.id_media) + "'"}                u = Utility()                search_dict = u.remove_empty_items_fr_dict(search_dict)                mediathumb_data = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                thumb_path_2 = str(mediathumb_data[0].filepath)                item = QListWidgetItem(str(i.media_name))                item.setData(Qt.UserRole,str(i.media_name))                icon = QIcon(thumb_path_str+thumb_path_2)                item.setIcon(icon)                self.iconListWidget_2.addItem(item)        elif mode == 1:            self.iconListWidget_2.clear()    def openWide_image(self):        items = self.iconListWidget.selectedItems()        items_2 = self.iconListWidget_2.selectedItems()        conn = Connection()                thumb_resize = conn.thumb_resize()        thumb_resize_str = thumb_resize['thumb_resize']        for item in items:            dlg = ImageViewer(self)            id_orig_item = item.text()  # return the name of original file            search_dict = {'media_filename': "'" + str(id_orig_item) + "'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            try:                res = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                file_path = str(res[0].path_resize)            except Exception as e:                QMessageBox.warning(self, "Error", "Warning 1 file: " + str(e), QMessageBox.Ok)            dlg.show_image(thumb_resize_str+file_path)            dlg.exec_()        for item_2 in items_2:            dlg_2 = ImageViewer()            id_orig_item = item_2.text()  # return the name of original file            search_dict = {'media_filename': "'" + str(id_orig_item) + "'" , 'mediatype': "'" + 'video' + "'"}             u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            #try:            res = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                                    search_dict_2 = {'media_filename': "'" + str(id_orig_item) + "'" , 'mediatype': "'" + 'image' + "'"}                          search_dict_2 = u.remove_empty_items_fr_dict(search_dict_2)            #try:            res_2 = self.DB_MANAGER.query_bool(search_dict_2, "MEDIA_THUMB")                        search_dict_3 = {'media_filename': "'" + str(id_orig_item) + "'"}                          search_dict_3 = u.remove_empty_items_fr_dict(search_dict_3)            #try:            res_3 = self.DB_MANAGER.query_bool(search_dict_3, "MEDIA_THUMB")                        # file_path = str(res[0].path_resize)            # file_path_2 = str(res_2[0].path_resize)            file_path_3 = str(res_3[0].path_resize)            if bool(res):                os.startfile(str(thumb_resize_str+file_path_3))            elif bool(res_2):                dlg_2.show_image(str(thumb_resize_str+file_path_3))                  dlg_2.exec_()    def on_pushButton_sort_pressed(self):        if self.check_record_state() == 1:            pass        else:            dlg = SortPanelMain(self)            dlg.insertItems(self.SORT_ITEMS)            dlg.exec_()            items, order_type = dlg.ITEMS, dlg.TYPE_ORDER            self.SORT_ITEMS_CONVERTED = []            for i in items:                self.SORT_ITEMS_CONVERTED.append(self.CONVERSION_DICT[str(i)])            self.SORT_MODE = order_type            self.empty_fields()            id_list = []            for i in self.DATA_LIST:                id_list.append(eval("i." + self.ID_TABLE))            self.DATA_LIST = []            temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE,                                                        self.MAPPER_TABLE_CLASS, self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.SORT_STATUS = "o"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)            self.fill_fields()    def on_pushButton_new_rec_pressed(self):        if bool(self.DATA_LIST):            if self.data_error_check() == 1:                pass            else:                if self.BROWSE_STATUS == "b":                    if self.DATA_LIST:                        if self.records_equal_check() == 1:                            self.update_if(QMessageBox.warning(self, 'Error',                                                               "The record has been changed. Do you want to save the changes?",                                                               QMessageBox.Ok | QMessageBox.Cancel))                            # set the GUI for a new record        if self.BROWSE_STATUS != "n":            self.BROWSE_STATUS = "n"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.empty_fields()                                   self.SORT_STATUS = "n"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.set_rec_counter('', '')            self.label_sort.setText(self.SORTED_ITEMS["n"])            self.empty_fields()            self.enable_button(0)    def on_pushButton_save_pressed(self):        # save record        if self.BROWSE_STATUS == "b":            if self.data_error_check() == 0:                if self.records_equal_check() == 1:                    self.update_if(QMessageBox.warning(self, 'Error',                                                       "The record has been changed. Do you want to save the changes?",                                                       QMessageBox.Ok | QMessageBox.Cancel))                    self.empty_fields()                                        self.SORT_STATUS = "n"                    self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])                    self.enable_button(1)                    self.fill_fields(self.REC_CORR)                                    else:                    QMessageBox.warning(self, "Warning", "No changes have been made", QMessageBox.Ok)        else:            if self.data_error_check() == 0:                test_insert = self.insert_new_rec()                if test_insert == 1:                    self.empty_fields()                    self.label_sort.setText(self.SORTED_ITEMS["n"])                    self.charge_list()                    self.charge_records()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                                        self.fill_fields(self.REC_CORR)                    self.enable_button(1)                else:                    pass    def insert_new_rec(self):        # TableWidget        ##Rapporti        photo = self.table2dict("self.tableWidget_photo")        ##Inclusi        video = self.table2dict("self.tableWidget_video")        if self.comboBox_years.currentText() == "":            years = 0        else:            years = int(self.comboBox_years.currentText())        if self.lineEdit_photo_nbr.text() == "":            photo_nbr = 0        else:            photo_nbr = int(self.lineEdit_photo_nbr.text())        if self.lineEdit_video_nbr.text() == "":            video_nbr = 0        else:            video_nbr = int(self.lineEdit_video_nbr.text())        try:            # data            data = self.DB_MANAGER.insert_uw_values(                self.DB_MANAGER.max_num_id(self.MAPPER_TABLE_CLASS, self.ID_TABLE) + 1,                int(self.lineEdit_divelog_id.text()),                str(self.comboBox_area_reference.currentText()),  # 1 - Sito                str(self.comboBox_diver.currentText()),  # 3 - US                str(self.comboBox_buddy.currentText()),  # 4 - Definizione stratigrafica                str(self.comboBox_add_diver.currentText()),  # 5 - Definizione intepretata                str(self.comboBox_standby_diver.currentText()),  # 6 - descrizione                str(self.textEdit_task.toPlainText()),                str(self.textEdit_result.toPlainText()),  #                str(self.comboBox_supervisor.currentText()),  # 11 - fase finale                str(self.lineEdit_bar_start1.text()),  # 12 - scavato                str(self.lineEdit_bar_end1.text()),  # 13 - attivita                str(self.lineEdit_uwtemperature.text()),  # 14 - anno scavo                str(self.lineEdit_uwvisibility.text()),  # 15 - metodo                str(self.comboBox_uwcurrents.currentText()),  # 16 - inclusi                str(self.comboBox_wind.currentText()),  # 17 - campioni                str(self.lineEdit_breathing_mix.text()),  # 18 - rapporti                str(self.lineEdit_max_depth.text()),  # 19 - data schedatura                str(self.lineEdit_surface_interval.text()),  # 20 - schedatore                str(self.textEdit_comments.toPlainText()),  # 21 - formazione                str(self.lineEdit_bottom_time.text()),  # 22 - conservazione                photo_nbr,  # 24 - consistenza                video_nbr,  # 25 - struttura                str(self.lineEdit_camera.text()),                str(self.lineEdit_time_in.text()),  # 9 - fase iniziale                str(self.lineEdit_time_out.text()),                str(self.lineEdit_date.text()),                years,  # 26 - continuita  periodo                str(self.lineEdit_dp1.text()),  # 27 - order layer                str(photo),                str(video),                str(self.comboBox_site.currentText()),                str(self.lineEdit_layers.text()),                str(self.lineEdit_bar_start_2.text()),                str(self.lineEdit_bar_end_2.text()),                str(self.lineEdit_dp_2.text())            )                        try:                self.DB_MANAGER.insert_data_session(data)                return 1            except Exception as e:                e_str = str(e)                if e_str.__contains__("IntegrityError"):                    msg = self.ID_TABLE + " exist in db"                    QMessageBox.warning(self, "Error", "Error" + str(msg), QMessageBox.Ok)                else:                    msg = e                    QMessageBox.warning(self, "Error", "Error 1 \n" + str(msg), QMessageBox.Ok)                return 0        except Exception as e:            QMessageBox.warning(self, "Error", "Error 2 \n" + str(e), QMessageBox.Ok)            return 0    # insert new row into tableWidget    def on_pushButton_insert_row_photo_pressed(self):        self.insert_new_row('self.tableWidget_photo')    def on_pushButton_remove_row_photo_pressed(self):        self.remove_row('self.tableWidget_photo')    def on_pushButton_insert_row_video_pressed(self):        self.insert_new_row('self.tableWidget_video')    def on_pushButton_remove_row_video_pressed(self):        self.remove_row('self.tableWidget_video')            def check_record_state(self):        ec = self.data_error_check()        if ec == 1:            return 1  # ci sono errori di immissione        elif self.records_equal_check() == 1 and ec == 0:            # self.update_if()            #self.charge_records()            return 0  # non ci sono errori di immissione    def on_pushButton_view_all_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.empty_fields()            self.charge_records()            self.fill_fields()            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.label_sort.setText(self.SORTED_ITEMS["n"])            if bool(self.toolButtonPreviewMedia.isChecked()):                self.loadMediaPreview(1)                self.loadMediaPreview_2(1)    def on_pushButton_first_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.fill_fields(0)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except:                pass    def on_pushButton_last_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                self.fill_fields(self.REC_CORR)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except :                pass        def data_error_check(self):        test = 0        EC = Error_check()        if EC.data_is_empty(str(self.comboBox_site.currentText())) == 0:            QMessageBox.warning(self, "WARNING", "site Field. \n The field must not be empty", QMessageBox.Ok)            test = 1        return test                def on_pushButton_prev_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR - 1        if self.REC_CORR == -1:            self.REC_CORR = 0            QMessageBox.warning(self, "Warning", "You are to the first record!", QMessageBox.Ok)        else:            try:                self.empty_fields()                self.fill_fields(self.REC_CORR)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except:                pass    def on_pushButton_next_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR + 1            if self.REC_CORR >= self.REC_TOT:                self.REC_CORR = self.REC_CORR - 1                QMessageBox.warning(self, "Error", "You are on the last record!", QMessageBox.Ok)            else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                except:                    pass  # QMessageBox.warning(self, "Errore", str(e),  QMessageBox.Ok)    def on_pushButton_delete_pressed(self):        msg = QMessageBox.warning(self, "Warning!!!",                                  "Do you really want to break the record? \n Action is irreversible.",                                  QMessageBox.Ok | QMessageBox.Cancel)        if msg == QMessageBox.Cancel:            QMessageBox.warning(self, "Message!!!", "Action deleted!")        else:            try:                id_to_delete = eval("self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE)                self.DB_MANAGER.delete_one_record(self.TABLE_NAME, self.ID_TABLE, id_to_delete)                self.charge_records()  # charge records from DB                QMessageBox.warning(self, "Message!!!", "Record deleted!")            except Exception as e:                QMessageBox.warning(self, "Message!!!", "error type: " + str(e))            if not bool(self.DATA_LIST):                QMessageBox.warning(self, "Warning", "the db is empty!", QMessageBox.Ok)                self.DATA_LIST = []                self.DATA_LIST_REC_CORR = []                self.DATA_LIST_REC_TEMP = []                self.REC_CORR = 0                self.REC_TOT = 0                self.empty_fields()                self.set_rec_counter(0, 0)                # check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])    def on_pushButton_new_search_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.enable_button_search(0)            # set the GUI for a new search            if self.BROWSE_STATUS != "f":                self.BROWSE_STATUS = "f"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                ###                # self.setComboBoxEnable(["self.comboBox_site"], "True")                # self.setComboBoxEditable(["self.comboBox_site"], 1)                # self.setComboBoxEnable(["self.comboBox_years"], "True")                # self.setComboBoxEditable(["self.comboBox_years"], 1)                # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "True")                ###                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter('', '')                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.charge_list()                self.empty_fields()        def on_pushButton_search_go_pressed(self):        #global check_for_buttons        if self.BROWSE_STATUS != "f":            QMessageBox.warning(self, "WARNING", "To perform a new search click on the 'new search' button ",                                QMessageBox.Ok)        else:            # TableWidget            if self.lineEdit_divelog_id.text() != "":                divelog_id = int(self.lineEdit_divelog_id.text())            else:                divelog_id = ""            if self.comboBox_years.currentText() != "":                years = int(self.comboBox_years.currentText())            else:                years = ""            if self.lineEdit_photo_nbr.text() != "":                photo_nbr = int(self.lineEdit_photo_nbr.text())            else:                photo_nbr = ""            if self.lineEdit_video_nbr.text() != "":                video_nbr = int(self.lineEdit_video_nbr.text())            else:                video_nbr = ""            # if self.lineEdit_layers.text() != "":            # layer = int(self.lineEdit_layers.text())            # else:            # layer = ""            ##qmax_usm            # if self.lineEdit_qmax_usm.text() != "":            # qmax_usm = float(self.lineEdit_qmax_usm.text())            # else:            # qmax_usm = None            search_dict = {                self.TABLE_FIELDS[0]: divelog_id,                self.TABLE_FIELDS[1]: "'" + str(self.comboBox_area_reference.currentText()) + "'",                self.TABLE_FIELDS[2]: "'" + str(self.comboBox_diver.currentText()) + "'",  # 2 - Area                self.TABLE_FIELDS[3]: "'" + str(self.comboBox_buddy.currentText()) + "'",  # 3 - US                self.TABLE_FIELDS[4]: "'" + str(self.comboBox_add_diver.currentText()) + "'",            # 4 - Definizione stratigrafica      self.TABLE_FIELDS[4]  : "'"+unicode(self.lineEdit__diver_3.text())+"'",                     #5 - Definizione intepretata                self.TABLE_FIELDS[5]: "'" + str(self.comboBox_standby_diver.currentText()) + "'",  # 6 - descrizione                self.TABLE_FIELDS[6]: str(self.textEdit_task.toPlainText()),  # 7 - interpretazione                self.TABLE_FIELDS[7]: str(self.textEdit_result.toPlainText()),            # 8 - periodo inizial                        #11 - fase finale                self.TABLE_FIELDS[8]: "'" + str(self.comboBox_supervisor.currentText()) + "'",  # 12 - scavato                self.TABLE_FIELDS[9]: "'" + str(self.lineEdit_bar_start1.text()) + "'",  # 13 - attivita                self.TABLE_FIELDS[10]: "'" + str(self.lineEdit_bar_end1.text()) + "'",  # 14 - anno scavo                self.TABLE_FIELDS[11]: "'" + str(self.lineEdit_uwtemperature.text()) + "'",  # 15 - metodo                self.TABLE_FIELDS[12]: "'" + str(self.lineEdit_uwvisibility.text()) + "'",  # 16 - data schedatura                self.TABLE_FIELDS[13]: "'" + str(self.comboBox_uwcurrents.currentText()) + "'",  # 17 - schedatore                self.TABLE_FIELDS[14]: "'" + str(self.comboBox_wind.currentText()) + "'",  # 18 - formazione                self.TABLE_FIELDS[15]: "'" + str(self.lineEdit_breathing_mix.text()) + "'",  # 19 - conservazione                self.TABLE_FIELDS[16]: "'" + str(self.lineEdit_max_depth.text()) + "'",  # 20 - colore                self.TABLE_FIELDS[17]: "'" + str(self.lineEdit_surface_interval.text()) + "'",  # 21 - consistenza                self.TABLE_FIELDS[18]: str(self.textEdit_comments.toPlainText()),                self.TABLE_FIELDS[19]: "'" + str(self.lineEdit_bottom_time.text()) + "'",  # 22 - struttura                self.TABLE_FIELDS[20]: photo_nbr,  # 23 - codice_periodo                self.TABLE_FIELDS[21]: video_nbr,  # 24 - order layer                self.TABLE_FIELDS[22]: "'" + str(self.lineEdit_camera.text()) + "'",  # 24 - order layer                self.TABLE_FIELDS[23]: "'" + str(self.lineEdit_time_in.text()) + "'",  # 24 - order layer                self.TABLE_FIELDS[24]: "'" + str(self.lineEdit_time_out.text()) + "'",                self.TABLE_FIELDS[25]: "'" + str(self.lineEdit_date.text()) + "'",                self.TABLE_FIELDS[26]: years,                self.TABLE_FIELDS[29]: "'" + str(self.lineEdit_dp1.text()) + "'",                self.TABLE_FIELDS[30]: "'" + str(self.comboBox_site.currentText()) + "'",                self.TABLE_FIELDS[31]: "'" + str(self.lineEdit_layers.text()) + "'",                self.TABLE_FIELDS[32]: "'" + str(self.lineEdit_bar_start_2.text()) + "'",                self.TABLE_FIELDS[33]: "'" + str(self.lineEdit_bar_end_2.text()) + "'",                self.TABLE_FIELDS[34]: "'" + str(self.lineEdit_dp_2.text()) + "'"            }            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            if not bool(search_dict):                QMessageBox.warning(self, " WARNING", "No search has been set!!!", QMessageBox.Ok)            else:                res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                if not bool(res):                    QMessageBox.warning(self, "WARNING", "No record found!", QMessageBox.Ok)                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields(self.REC_CORR)                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    # self.setComboBoxEnable(["self.comboBox_site"], "True")                    # self.setComboBoxEditable(["self.comboBox_site"], 1)                    # self.setComboBoxEnable(["self.comboBox_years"], "True")                    # self.setComboBoxEditable(["self.comboBox_years"], 1)                    # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "True")                else:                    self.DATA_LIST = []                    for i in res:                        self.DATA_LIST.append(i)                    ##                  if self.DB_SERVER == 'sqlite':                    ##                      for i in self.DATA_LIST:                    ##                          self.DB_MANAGER.update(self.MAPPER_TABLE_CLASS, self.ID_TABLE, [i.id_sito], ['find_check'], [1])                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]  ####darivedere                    self.fill_fields()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                    if self.REC_TOT == 1:                        strings = ("It has been found", self.REC_TOT, "record")                                            else:                        strings = ("They have been found", self.REC_TOT, "records")                                            # self.setComboBoxEnable(["self.comboBox_artefact"], "True")                    # self.setComboBoxEditable(["self.comboBox_artefact"], 1)                    # self.setComboBoxEnable(["self.comboBox_site"], "True")                    # self.setComboBoxEditable(["self.comboBox_site"], 1)                                                            QMessageBox.warning(self, "Messaggio", "%s %d %s" % strings, QMessageBox.Ok)                        self.enable_button_search(1)    def update_if(self, msg):        rec_corr = self.REC_CORR        if msg == QMessageBox.Ok:            test = self.update_record()            if test == 1:                id_list = []                for i in self.DATA_LIST:                    id_list.append(eval("i." + self.ID_TABLE))                self.DATA_LIST = []                if self.SORT_STATUS == "n":                    temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc',                                                                self.MAPPER_TABLE_CLASS,                                                                self.ID_TABLE)  # self.DB_MANAGER.query_bool(self.SEARCH_DICT_TEMP, self.MAPPER_TABLE_CLASS) #                else:                    temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE,                                                                self.MAPPER_TABLE_CLASS, self.ID_TABLE)                for i in temp_data_list:                    self.DATA_LIST.append(i)                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                if type(self.REC_CORR) == "<type 'str'>":                    corr = 0                else:                    corr = self.REC_CORR                return 1            elif test == 0:                return 0    def update_record(self):        try:            self.DB_MANAGER.update(self.MAPPER_TABLE_CLASS,                                   self.ID_TABLE,                                   [eval("int(self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE + ")")],                                   self.TABLE_FIELDS,                                   self.rec_toupdate())            return 1        except Exception as e:            QMessageBox.warning(self, "Message",                                "encoding problem: accents or characters not accepted by the database have been inserted. If you close the card now without correcting the errors you will lose the data. Make a copy of everything on a separate word sheet. Error :" + str(                                    e), QMessageBox.Ok)            return 0    def rec_toupdate(self):        rec_to_update = self.UTILITY.pos_none_in_list(self.DATA_LIST_REC_TEMP)        return rec_to_update    # custom functions    def charge_records(self):        self.DATA_LIST = []        if self.DB_SERVER == 'sqlite':            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                self.DATA_LIST.append(i)        else:            id_list = []            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                id_list.append(eval("i." + self.ID_TABLE))            temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc', self.MAPPER_TABLE_CLASS,                                                        self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)    def datestrfdate(self):        now = date.today()        today = now.strftime("%d-%m-%Y")        return today    def yearstrfdate(self):        now = date.today()        year = now.strftime("%Y")        return year    def table2dict(self, n):        self.tablename = n        row = eval(self.tablename + ".rowCount()")        col = eval(self.tablename + ".columnCount()")        lista = []        for r in range(row):            sub_list = []            for c in range(col):                value = eval(self.tablename + ".item(r,c)")                if value != None:                    sub_list.append(str(value.text()))            if bool(sub_list):                lista.append(sub_list)        return lista    def tableInsertData(self, t, d):        """Set the value into alls Grid"""        self.table_name = t        self.data_list = eval(d)        self.data_list.sort()        # column table count        table_col_count_cmd = "{}.columnCount()".format(self.table_name)        table_col_count = eval(table_col_count_cmd)        # clear table        table_clear_cmd = "{}.clearContents()".format(self.table_name)        eval(table_clear_cmd)        for i in range(table_col_count):            table_rem_row_cmd = "{}.removeRow(int({}))".format(self.table_name, i)            eval(table_rem_row_cmd)            # for i in range(len(self.data_list)):            # self.insert_new_row(self.table_name)        for row in range(len(self.data_list)):            cmd = '{}.insertRow(int({}))'.format(self.table_name, row)            eval(cmd)            for col in range(len(self.data_list[row])):                # item = self.comboBox_site.setEditText(self.data_list[0][col]                # item = QTableWidgetItem(self.data_list[row][col])                # TODO SL: evauation of QTableWidget does not work porperly                exec_str = '{}.setItem(int({}),int({}),QTableWidgetItem(self.data_list[row][col]))'.format(                    self.table_name, row, col)                eval(exec_str)    def insert_new_row(self, table_name):        """insert new row into a table based on table_name"""        cmd = table_name + ".insertRow(0)"        eval(cmd)    def remove_row(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        rowIndex = (rowSelected[0].row())        cmd = ("%s.removeRow(%d)") % (table_name, rowIndex)        eval(cmd)    def empty_fields(self):        photo_row_count = self.tableWidget_photo.rowCount()        video_row_count = self.tableWidget_video.rowCount()  # 1 - Sito        self.lineEdit_divelog_id.clear()        self.comboBox_area_reference.setEditText("")        self.comboBox_diver.setEditText("")  # 2 - Area        self.comboBox_buddy.setEditText("")  # 3 - US        self.comboBox_add_diver.setEditText("")         self.comboBox_standby_diver.setEditText("")  # 6 - descrizione        self.textEdit_task.clear()        self.textEdit_result.clear()        self.comboBox_supervisor.setEditText("")  # 11 - fase finale        self.lineEdit_bar_start1.clear()  # 12 - scavato        self.lineEdit_bar_end1.clear()        self.lineEdit_uwtemperature.clear()  # 13 - attivita        self.lineEdit_uwvisibility.clear()        self.comboBox_uwcurrents.setEditText("")        self.comboBox_wind.setEditText("")        self.lineEdit_breathing_mix.clear()        self.lineEdit_max_depth.clear()        self.lineEdit_surface_interval.clear()        self.textEdit_comments.clear()        self.lineEdit_bottom_time.clear()        self.lineEdit_photo_nbr.clear()        self.lineEdit_video_nbr.clear()        self.lineEdit_camera.clear()        self.lineEdit_time_in.clear()  # 9 - fase iniziale        self.lineEdit_time_out.clear()        self.lineEdit_date.clear()        self.comboBox_years.setEditText("")        self.lineEdit_dp1.clear()        self.comboBox_site.setEditText("")        self.lineEdit_layers.clear()        self.lineEdit_bar_start_2.clear()        self.lineEdit_bar_end_2.clear()        self.lineEdit_dp_2.clear()        for i in range(photo_row_count):            self.tableWidget_photo.removeRow(0)        self.insert_new_row("self.tableWidget_photo")  # 16 - inclusi        for i in range(video_row_count):            self.tableWidget_video.removeRow(0)        self.insert_new_row("self.tableWidget_video")  # 17 - campioni    def fill_fields(self, n=0):        self.rec_num = n        # QMessageBox.warning(self, "Test", str(self.comboBox_per_fin.currentText()),  QMessageBox.Ok)        try:            # 1 - Sito            self.lineEdit_divelog_id.setText(str(self.DATA_LIST[self.rec_num].divelog_id))            str(self.comboBox_area_reference.setEditText(self.DATA_LIST[self.rec_num].area_id))            str(self.comboBox_diver.setEditText(self.DATA_LIST[self.rec_num].diver_1))  # 2 - Area            str(self.comboBox_buddy.setEditText(self.DATA_LIST[self.rec_num].diver_2))            str(self.comboBox_add_diver.setEditText(self.DATA_LIST[self.rec_num].additional_diver))            str(self.comboBox_standby_diver.setEditText(self.DATA_LIST[self.rec_num].standby_diver))            str(self.textEdit_task.setText(self.DATA_LIST[self.rec_num].task))            str(self.textEdit_result.setText(self.DATA_LIST[self.rec_num].result))            str(self.comboBox_supervisor.setEditText(self.DATA_LIST[self.rec_num].dive_supervisor))            str(self.lineEdit_bar_start1.setText(self.DATA_LIST[self.rec_num].bar_start_diver1))            str(self.lineEdit_bar_end1.setText(self.DATA_LIST[self.rec_num].bar_end_diver1))            str(self.lineEdit_uwtemperature.setText(self.DATA_LIST[self.rec_num].uw_temperature))            str(self.lineEdit_uwvisibility.setText(self.DATA_LIST[self.rec_num].uw_visibility))            str(self.comboBox_uwcurrents.setEditText(self.DATA_LIST[self.rec_num].uw_current_))            str(self.comboBox_wind.setEditText(self.DATA_LIST[self.rec_num].wind))            str(self.lineEdit_breathing_mix.setText(self.DATA_LIST[self.rec_num].breathing_mix))            str(self.lineEdit_max_depth.setText(self.DATA_LIST[self.rec_num].max_depth))            str(self.lineEdit_surface_interval.setText(self.DATA_LIST[self.rec_num].surface_interval))            str(self.textEdit_comments.setText(self.DATA_LIST[self.rec_num].comments_))            str(self.lineEdit_bottom_time.setText(self.DATA_LIST[self.rec_num].bottom_time))            self.lineEdit_photo_nbr.setText(str(self.DATA_LIST[self.rec_num].photo_nbr))            self.lineEdit_video_nbr.setText(str(self.DATA_LIST[self.rec_num].video_nbr))            str(self.lineEdit_camera.setText(self.DATA_LIST[self.rec_num].camera))            str(self.lineEdit_time_in.setText(self.DATA_LIST[self.rec_num].time_in))            str(self.lineEdit_time_out.setText(self.DATA_LIST[self.rec_num].time_out))            str(self.lineEdit_date.setText(self.DATA_LIST[self.rec_num].date_))            self.comboBox_years.setEditText(str(self.DATA_LIST[self.rec_num].years))            str(self.lineEdit_dp1.setText(self.DATA_LIST[self.rec_num].dp_diver1))            self.tableInsertData("self.tableWidget_photo", self.DATA_LIST[self.rec_num].photo_id)            self.tableInsertData("self.tableWidget_video", self.DATA_LIST[self.rec_num].video_id)            str(self.comboBox_site.setEditText(self.DATA_LIST[self.rec_num].site))            str(self.lineEdit_layers.setText(self.DATA_LIST[self.rec_num].layer))            str(self.lineEdit_bar_start_2.setText(self.DATA_LIST[self.rec_num].bar_start_diver2))            str(self.lineEdit_bar_end_2.setText(self.DATA_LIST[self.rec_num].bar_end_diver2))            str(self.lineEdit_dp_2.setText(self.DATA_LIST[self.rec_num].dp_diver2))            if self.toolButtonPreviewMedia.isChecked() == True:                self.loadMediaPreview()                self.loadMediaPreview_2()                self.loadMedialist()        except :            pass                def generate_list_pdf(self):        data_list = []        for i in range(len(self.DATA_LIST)):                    data_list.append([            int(self.DATA_LIST[i].divelog_id),                                  #1 - Sito            str(self.DATA_LIST[i].area_id),                                 #2 - Area                       #1 - Sito            str(self.DATA_LIST[i].diver_1),                                         #3 - US            str(self.DATA_LIST[i].diver_2),                     #4 - Definizione stratigrafica            str(self.DATA_LIST[i].additional_diver),                     #5 - Definizione intepretata            str(self.DATA_LIST[i].standby_diver),                   #6 - descrizione            str(self.DATA_LIST[i].task),            str(self.DATA_LIST[i].result),      #7 - interpretazione            str(self.DATA_LIST[i].dive_supervisor),                      #11 - fase finale            str(self.DATA_LIST[i].bar_start_diver1),                       #12 - scavato            str(self.DATA_LIST[i].bar_end_diver1),                         #13 - attivita            str(self.DATA_LIST[i].uw_temperature),                             #14 - anno scavo            str(self.DATA_LIST[i].uw_visibility),                      #15 - metodo            str(self.DATA_LIST[i].uw_current_),                                                    #16 - inclusi            str(self.DATA_LIST[i].wind),                                                    #17 - campioni            str(self.DATA_LIST[i].breathing_mix),                                                   #18 - rapporti            str(self.DATA_LIST[i].max_depth),                       #19 - data schedatura            str(self.DATA_LIST[i].surface_interval),                    #20 - schedatore            str(self.DATA_LIST[i].comments_),                   #21 - formazione            str(self.DATA_LIST[i].bottom_time),             #22 - conservazione            int(self.DATA_LIST[i].photo_nbr),                   #24 - consistenza            int(self.DATA_LIST[i].video_nbr),                               #25 - struttura            str(self.DATA_LIST[i].camera),            str(self.DATA_LIST[i].time_in),                     #9 - fase iniziale            str(self.DATA_LIST[i].time_out),            str(self.DATA_LIST[i].date_),            str(self.DATA_LIST[i].years),            str(self.DATA_LIST[i].dp_diver1),            str(self.DATA_LIST[i].photo_id),            str(self.DATA_LIST[i].video_id),            str(self.DATA_LIST[i].site),            str(self.DATA_LIST[i].layer),            str(self.DATA_LIST[i].bar_start_diver2),            str(self.DATA_LIST[i].bar_end_diver2),            str(self.DATA_LIST[i].dp_diver2) #29 - documentazione            ])        return data_list    def on_pushButton_exppdf_pressed(self):        US_pdf_sheet = generate_US_pdf()        data_list = self.generate_list_pdf()        US_pdf_sheet.build_US_sheets(data_list)            P_pdf_sheet = generate_photo_pdf()        data_list = self.generate_list_pdf()        P_pdf_sheet.build_P_sheets(data_list,data_list[0][30])    def on_pushButton_explist_pressed(self):        US_index_pdf = generate_US_pdf()        data_list = self.generate_list_pdf()        US_index_pdf.build_index_US(data_list, data_list[0][0])    def set_rec_counter(self, t, c):        self.rec_tot = t        self.rec_corr = c        self.label_rec_tot.setText(str(self.rec_tot))        self.label_rec_corrente.setText(str(self.rec_corr))    def set_LIST_REC_TEMP(self):                video_id = self.table2dict("self.tableWidget_video")                photo_id = self.table2dict("self.tableWidget_photo")                self.DATA_LIST_REC_TEMP = [            str(self.lineEdit_divelog_id.text()),            str(self.comboBox_area_reference.currentText()),  # 1 - Sito            str(self.comboBox_diver.currentText()),  # 3 - US            str(self.comboBox_buddy.currentText()),  # 4 - Definizione stratigrafica            str(self.comboBox_add_diver.currentText()),  # 5 - Definizione intepretata            str(self.comboBox_standby_diver.currentText()),  # 6 - descrizione            str(self.textEdit_task.toPlainText()),            str(self.textEdit_result.toPlainText()),  # 7 - interpretazione            str(self.comboBox_supervisor.currentText()),  # 11 - fase finale            str(self.lineEdit_bar_start1.text()),  # 12 - scavato            str(self.lineEdit_bar_end1.text()),  # 13 - attivita            str(self.lineEdit_uwtemperature.text()),  # 14 - anno scavo            str(self.lineEdit_uwvisibility.text()),  # 15 - metodo            str(self.comboBox_uwcurrents.currentText()),  # 16 - inclusi            str(self.comboBox_wind.currentText()),  # 17 - campioni            str(self.lineEdit_breathing_mix.text()),  # 18 - rapporti            str(self.lineEdit_max_depth.text()),  # 19 - data schedatura            str(self.lineEdit_surface_interval.text()),  # 20 - schedatore            str(self.textEdit_comments.toPlainText()),  # 21 - formazione            str(self.lineEdit_bottom_time.text()),  # 22 - conservazione            str(self.lineEdit_photo_nbr.text()),  # 24 - consistenza            str(self.lineEdit_video_nbr.text()),  # 25 - struttura            str(self.lineEdit_camera.text()),            str(self.lineEdit_time_in.text()),  # 9 - fase iniziale            str(self.lineEdit_time_out.text()),            str(self.lineEdit_date.text()),            str(self.comboBox_years.currentText()),            str(self.lineEdit_dp1.text()),            str(photo_id),            str(video_id),            str(self.comboBox_site.currentText()),            str(self.lineEdit_layers.text()),            str(self.lineEdit_bar_start_2.text()),            str(self.lineEdit_bar_end_2.text()),            str(self.lineEdit_dp_2.text())        ]    def set_LIST_REC_CORR(self):        self.DATA_LIST_REC_CORR = []        for i in self.TABLE_FIELDS:            self.DATA_LIST_REC_CORR.append(eval("unicode(self.DATA_LIST[self.REC_CORR]." + i + ")"))    def records_equal_check(self):        self.set_LIST_REC_TEMP()        self.set_LIST_REC_CORR()        # check_str = str(self.DATA_LIST_REC_CORR) + " " + str(self.DATA_LIST_REC_TEMP)        if self.DATA_LIST_REC_CORR == self.DATA_LIST_REC_TEMP:            return 0        else:            return 1    def setComboBoxEditable(self, f, n):        field_names = f        value = n        for fn in field_names:            cmd = '{}{}{}{}'.format(fn, '.setEditable(', n, ')')            eval(cmd)    def setComboBoxEnable(self, f, v):        field_names = f        value = v        for fn in field_names:            cmd = '{}{}{}{}'.format(fn, '.setEnabled(', v, ')')            eval(cmd)    def setTableEnable(self, t, v):        tab_names = t        value = v        for tn in tab_names:            cmd = '{}{}{}{}'.format(tn, '.setEnabled(', v, ')')            eval(cmd)    def testing(self, name_file, message):        f = open(str(name_file), 'w')        f.write(str(message))        f.close()    def on_pushButton_cerca_pressed(self):        self.provo = str(self.lineEdit_testo.text()) # inserimento parola da cercare. se usi le virgolette ti cerca la frase per intero altrimenti splitta ogni sigola parola        es.indices.refresh(index="uw")        res = es.search(index="uw", body={"query":{"bool":{"should":[{"query_string":{"default_field":"result","query":self.provo,"default_operator": "AND"}},{"query_string":{"default_field":"task","query":self.provo,"default_operator": "AND"}},{"query_string":{"default_field":"comments_","query":self.provo}}],"must_not":[]}},"from":0,"size":1000,"sort":[{"divelog_id":{"order":"asc"}}],"aggs":{}}) # query sul campo testuale. in questo caso il mio campo su result        if not bool (res):            QMessageBox.warning(self, "Opss", "no record found", QMessageBox.Ok)        else:            QMessageBox.warning(self, "ok", "click on go to", QMessageBox.Ok)        for hit in res['hits']['hits']:# risultato nella liswidget mi indica in quale schede trovo la parola o frase che ho cercato. il risultato sito divelog ID e anno            numRows = self.tableWidget_risultato.rowCount()            self.tableWidget_risultato.insertRow(numRows)            self.tableWidget_risultato.setItem(numRows, 0, QTableWidgetItem("%(site)s" % hit["_source"]))            self.tableWidget_risultato.setItem(numRows, 1, QTableWidgetItem("%(years)s" % hit["_source"]))            self.tableWidget_risultato.setItem(numRows, 2, QTableWidgetItem("%(divelog_id)s" % hit["_source"]))    def remove_row_r(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        rowIndex = (rowSelected[0].row())        cmd = ("%s.removeRow(%d)") % (table_name,rowIndex)        eval(cmd)    def on_pushButton_remove_list_pressed(self): # rimuovo il risultato dalla list widget          risultato_count = self.tableWidget_risultato.rowCount()        self.remove_row_r("self.tableWidget_risultato")        for i in range(risultato_count):            self.tableWidget_risultato.removeRow(0)            self.lineEdit_testo.clear()    def on_pushButton_go_to_pressed(self):        try:            table_name = "self.tableWidget_risultato"            rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            rowSelected = eval(rowSelected_cmd)            rowIndex = (rowSelected[0].row())            sito_item = self.tableWidget_risultato.item(rowIndex,0)            site = str(sito_item.text())            years_item = self.tableWidget_risultato.item(rowIndex,1)            years = str(years_item.text())            us_item = self.tableWidget_risultato.item(rowIndex,2)            divelog_id = str(us_item.text())            search_dict = {'site': "'" + str(site) + "'",            'years': years,            'divelog_id': divelog_id}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)            if not bool(res):                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.fill_fields(self.REC_CORR)                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                # self.setComboBoxEnable(["self.comboBox_site"], "False")                # self.setComboBoxEnable(["self.comboBox_years"], "False")                # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "False")            else:                self.empty_fields()                self.DATA_LIST = []            for i in res:                self.DATA_LIST.append(i)                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.fill_fields()                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                # self.setComboBoxEnable(["self.comboBox_site"], "False")                # self.setComboBoxEnable(["self.comboBox_years"], "False")                # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "False")        except Exception as e:            e = str(e)            QMessageBox.warning(self, "Alert", "no row selected. Error python: %s " % (str(e)),            QMessageBox.Ok)        #with open(file_path, mode='rt', encoding='utf-8') as f:        self.provo = str(self.lineEdit_testo.text())        self.result = str(self.textEdit_result.toPlainText())        self.task = str(self.textEdit_task.toPlainText())        self.comments = str(self.textEdit_comments.toPlainText())        text = '<p>Result</p></br>' + self.result + '<p>Task</p></br>' + self.task + '<p>Comment</p>' + self.comments        #### funzione per evidenziare il testo ricercato in un file html        if self.provo in text:            with open("C:/elasticsearch-5.3.3/test1.html", mode='wt', encoding='utf-8') as f:                f.write(text.replace(self.provo, '<strong><span style="color: red">{}</span></strong>'.format(self.provo)))        else:            print("The word is not in the text")    def on_pushButtonQuant_pressed(self):        dlg = QuantPanelMain(self)        dlg.insertItems(self.QUANT_ITEMS)        dlg.exec_()        dataset = []        parameter1 = dlg.TYPE_QUANT        parameters2 = dlg.ITEMS        # QMessageBox.warning(self, "Test Parametri Quant", str(parameters2),  QMessageBox.Ok)        contatore = 0        # tipi di quantificazione        ##per forme minime        if parameter1 == 'QTY':            for i in range(len(self.DATA_LIST)):                temp_dataset = ()                try:                    temp_dataset = (self.parameter_quant_creator(parameters2, i), int(self.DATA_LIST[i].divelog_id))                    contatore += int(self.DATA_LIST[i].divelog_id)  # conteggio totale                    dataset.append(temp_dataset)                except:                    pass            # QMessageBox.warning(self, "Totale", str(contatore),  QMessageBox.Ok)            if bool(dataset) == True:                dataset_sum = self.UTILITY.sum_list_of_tuples_for_value(dataset)                csv_dataset = []                for sing_tup in dataset_sum:                    sing_list = [sing_tup[0], str(sing_tup[1])]                    csv_dataset.append(sing_list)                filename = ('%s%squant_qty.txt') % (self.QUANT_PATH, os.sep)                # QMessageBox.warning(self, "Esportazione", str(filename), MessageBox.Ok)                f = open(filename, 'wb')                uw = UnicodeWriter(f)                uw.writerows(csv_dataset)                f.close()                self.plot_chart(dataset_sum, 'Frequency analisys', 'Qty')            else:                QMessageBox.warning(self, "Warning", "The datas not are present", QMessageBox.Ok)    def parameter_quant_creator(self, par_list, n_rec):        self.parameter_list = par_list        self.record_number = n_rec        converted_parameters = []        for par in self.parameter_list:            converted_parameters.append(self.CONVERSION_DICT[par])        parameter2 = ''        for sing_par_conv in range(len(converted_parameters)):            exec_str = ('str(self.DATA_LIST[%d].%s)') % (self.record_number, converted_parameters[sing_par_conv])            paramentro = str(self.parameter_list[sing_par_conv])            exec_str = ' -' + paramentro[:4] + ": " + eval(exec_str)            parameter2 += exec_str        return parameter2    def plot_chart(self, d, t, yl):        global data_diz        self.data_list = d        self.title = t        self.ylabel = yl        if type(self.data_list) == list:            data_diz = {}            for item in self.data_list:                data_diz[item[0]] = item[1]        x = list(range(len(data_diz)))        n_bars = len(data_diz)        values = list(data_diz.values())        teams = list(data_diz.keys())        #ind = np.arange(n_bars)        # randomNumbers = random.sample(range(0, 10), 10)        self.widget.canvas.ax.clear()        # QMessageBox.warning(self, "Alert", str(teams) ,  QMessageBox.Ok)        bars = self.widget.canvas.ax.bar(left=x, height=values, width=0.5, align='center', alpha=0.4, picker=5)        # guardare il metodo barh per barre orizzontali        self.widget.canvas.ax.set_title(self.title)        self.widget.canvas.ax.set_ylabel(self.ylabel)        l = []        for team in teams:            l.append('""')        # self.widget.canvas.ax.set_xticklabels(x , ""   ,size = 'x-small', rotation = 0)        n = 0        for bar in bars:            val = int(bar.get_height())            x_pos = bar.get_x() + 0.25            label = teams[n] + ' - ' + str(val)            y_pos = 0.1  # bar.get_height() - bar.get_height() + 1            self.widget.canvas.ax.tick_params(axis='x', labelsize=8)            # self.widget.canvas.ax.set_xticklabels(ind + x, ['fg'], position = (x_pos,y_pos), xsize = 'small', rotation = 90)            self.widget.canvas.ax.text(x_pos, y_pos, label, zorder=0, ha='center', va='bottom', size='x-small',                                       rotation=90)            n += 1        # self.widget.canvas.ax.plot(randomNumbers)        self.widget.canvas.draw()    def on_pushButton_uw_geometry_pressed(self):        site = str(self.comboBox_site.currentText())        self.pyQGIS.charge_uw_geometry([],                                          "site", site)    def on_pushButton_track_pressed(self):        site = str(self.comboBox_site.currentText())        self.pyQGIS.charge_track_geometry([],                                          "name_site", site)                                       def on_pushButton_open_dir_pressed(self):        HOME = os.environ['HFF_HOME']        path = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])