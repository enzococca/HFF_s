#!/env/python# coding=utf8"""/***************************************************************************        HFF_system Plugin  - A QGIS plugin to manage archaeological dataset                             stored in Postgres                             -------------------    begin                : 2007-12-01    copyright            : (C) 2008 by Luca Mandolesi    email                : mandoluca at gmail.com ***************************************************************************//*************************************************************************** *                                                                          * *   This program is free software; you can redistribute it and/or modify   * *   it under the terms of the GNU General Public License as published by   * *   the Free Software Foundation; either version 2 of the License, or      * *   (at your option) any later version.                                    *                                                                       * ***************************************************************************/"""from __future__ import absolute_importimport osimport refrom datetime import dateimport sysimport platformimport subprocessimport numpy as npimport refrom builtins import rangefrom builtins import strfrom datetime import datefrom qgis.core import QgsSettingsfrom qgis.PyQt.QtCore import *from qgis.PyQt.QtGui import QColor, QIconfrom qgis.PyQt.QtWidgets import *from qgis.PyQt.QtSql import QSqlDatabase, QSqlTableModelfrom qgis.PyQt.uic import loadUiTypefrom qgis.gui import QgsMapCanvas, QgsMapToolPanfrom geoalchemy2 import *from sqlalchemy.event import listenfrom sqlalchemy.sql import select, funcfrom geoalchemy2 import func as funcgeomfrom sqlalchemy import create_enginefrom sqlalchemy.dialects import postgresqlfrom sqlalchemy.dialects.postgresql import insertfrom sqlalchemy.ext.compiler import compilesfrom sqlalchemy.sql.expression import *from ..modules.utility.hff_system__OS_utility import Hff_OS_Utilityfrom ..modules.db.hff_system__conn_strings import Connectionfrom ..modules.db.hff_db_manager import Hff_db_managementfrom ..modules.db.hff_system__utility import Utilityfrom ..modules.gis.hff_system__pyqgis import Hff_pyqgisfrom ..modules.utility.delegateComboBox import ComboBoxDelegatefrom ..modules.utility.hff_system__error_check import Error_checkfrom ..modules.utility.hff_system__exp_shipwrecksheet_pdf import *from ..modules.utility.csv_writer import UnicodeWriterfrom ..modules.utility.hff_system__print_utility import Print_utilityfrom ..gui.imageViewer import ImageViewerfrom ..gui.sortpanelmain import SortPanelMainfrom ..gui.quantpanelmain import QuantPanelMainimport pyprojfrom pyproj import ProjMAIN_DIALOG_CLASS, _ = loadUiType(    os.path.join(os.path.dirname(__file__), os.pardir, 'gui', 'ui', 'hff_system__SHIPWRECK_ui.ui'))class hff_system__Shipwreck(QDialog, MAIN_DIALOG_CLASS):    L=QgsSettings().value("locale/userLocale")[0:2]    MSG_BOX_TITLE = "HFF - Shipwreck form"    DATA_LIST = []    DATA_LIST_REC_CORR = []    DATA_LIST_REC_TEMP = []    REC_CORR = 0    REC_TOT = 0    STATUS_ITEMS = {"b": "Current", "f": "Find", "n": "New Record"}    BROWSE_STATUS = "b"    SORT_MODE = 'asc'    SORTED_ITEMS = {"n": "Not sorted", "o": "Sorted"}    SORT_STATUS = "n"    SORT_ITEMS_CONVERTED = ''    UTILITY = Utility()    DB_MANAGER = ""    HOME = os.environ['HFF_HOME']    PDFFOLDER = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")    TABLE_NAME = 'shipwreck_table'    MAPPER_TABLE_CLASS = "SHIPWRECK"    NOME_SCHEDA = "Shipwreck Form"    ID_TABLE = "id_shipwreck"    ID_SITO ="nationality"    CONVERSION_DICT = {    ID_TABLE:ID_TABLE,    "Code id":"code_id",     "Name Vessel":"name_vessel",    "Yard":"yard",    "Area":"area",    "Category":"category",    "Confidence":"confidence",    "Propulsion":"propulsion",    "Material":"material",    "Nationality":"nationality",    "Type":"type",    "Owner":"owner",    "Purpose":"purpose",    "Builder":"builder",    "Cause":"cause",    "Accessibility to divers":"divers",    "Position of wreck":"wreck",    "Sea bed composition":"composition",    "Sea bed inclination":"inclination",    "Depth Max-Min":"depth_max_min",    "Depth quality" : "depth_quality",    "Latitude" : "latitude",    "Position Quality 1" : "position_quality_1",    "Longitude" : "Longitude",    "Consulties" : "consulties",    "Length":"l",    "Width":"w",    "Draught":"d",    "Tonnage":"t",    "Conserved length":"cl",    "Conserved width":"cw",    "Conserved draught":"cd",    "Nickname":"nickname",    "Date built":"date_built",    "Date lost":"date_lost",    "Description":"description",    "History":"history",    "List":"list",    "Name":"name",    "Status":"status"    }    SORT_ITEMS = [                ID_TABLE,                "Code id",                 "Name Vessel",                "Yard",                "Area",                "Category",                "Confidence",                "Propulsion",                "Material",                "Nationality",                "Type",                "Owner",                "Purpose",                "Builder",                "Cause",                "Accessibility to divers",                "Position of wreck",                "Sea bed composition",                "Sea bed inclination",                #"Name"                                ]    QUANT_ITEMS = [                'Code id',                 'Name Vessel',                'Yard',                'Area',                'Category',                'Confidence',                'Propulsion',                'Material',                'Nationality',                'Type',                'Owner',                'Purpose',                'Builder',                'Cause',                'Accessibility to divers',                'Position of wreck',                'Sea bed composition',                'Sea bed inclination',                #'Name'                ]    TABLE_FIELDS_UPDATE = [                    "code_id",                     "name_vessel",                    "yard",                    "area",                    "category",                    "confidence",                    "propulsion",                    "material",                    "nationality",                    "type",                    "owner",                    "purpose",                    "builder",                    "cause",                    "divers",                    "wreck",                    "composition",                    "inclination",                    "depth_max_min",                    "depth_quality",                    "latitude",                    "position_quality_1",                    "longitude",                    "consulties",                    "l",                    "w",                    "d",                    "t",                    "cl",                    "cw",                    "cd",                    "nickname",                    "date_built",                    "date_lost",                    "description",                    "history",                    "list",                    "name",                    "status"                    ]           TABLE_FIELDS = [                    'code_id',                     'name_vessel',                    'yard',                    'area',                    'category',                    'confidence',                    'propulsion',                    'material',                    'nationality',                    'type',                    'owner',                    'purpose',                    'builder',                    'cause',                    'divers',                    'wreck',                    'composition',                    'inclination',                    'depth_max_min',                    'depth_quality',                    'latitude',                    'position_quality_1',                    'longitude',                    'consulties',                    'l',                    'w',                    'd',                    't',                    'cl',                    'cw',                    'cd',                    'nickname',                    'date_built',                    'date_lost',                    'description',                    'history',                    'list',                    'name',                    'status',                                        ]    # LANG = {        # "IT": ['it_IT', 'IT', 'it', 'IT_IT'],        # "EN_US": ['en_US','EN_US','en','EN'],        # "DE": ['de_DE','de','DE', 'DE_DE'],        # #"FR": ['fr_FR','fr','FR', 'FR_FR'],        # #"ES": ['es_ES','es','ES', 'ES_ES'],        # #"PT": ['pt_PT','pt','PT', 'PT_PT'],        # #"SV": ['sv_SV','sv','SV', 'SV_SV'],        # #"RU": ['ru_RU','ru','RU', 'RU_RU'],        # #"RO": ['ro_RO','ro','RO', 'RO_RO'],        # #"AR": ['ar_AR','ar','AR', 'AR_AR'],        # #"PT_BR": ['pt_BR','PT_BR'],        # #"SL": ['sl_SL','sl','SL', 'SL_SL'],    # }        REPORT_PATH = '{}{}{}'.format(HOME, os.sep, "HFF_Report_folder")    DB_SERVER = "not defined"  ####nuovo sistema sort    SEARCH_DICT_TEMP = ""    QUANT_PATH = '{}{}{}'.format(HOME, os.sep, "HFF_statistic_folder")        def __init__(self, iface):        super().__init__()        self.iface = iface        self.pyQGIS = Hff_pyqgis(iface)        self.setupUi(self)        self.mDockWidget_2.setHidden(True)        self.mDockWidget_export.setHidden(True)        self.currentLayerId = None        #HOME = os.environ['HFF_HOME']        try:            self.on_pushButton_connect_pressed()        except Exception as e:            QMessageBox.warning(self, "Connection System", str(e), QMessageBox.Ok)        code = self.comboBox_code.currentText()        self.comboBox_code.setEditText(code)        self.search_1.textChanged.connect(self.update_filter)        self.checkBox_query.update()        self.checkBox_query.stateChanged.connect(self.listview_us)###anche         self.empty_fields()        self.fill_fields()        self.customize_GUI()        self.show()        #self.loadMedialist()            def load_spatialite(self,conn, connection_record):        conn.enable_load_extension(True)        if Hff_OS_Utility.isWindows()== True:            conn.load_extension('mod_spatialite.dll')        elif Hff_OS_Utility.isMac()== True:            conn.load_extension('mod_spatialite.dylib')        else:            conn.load_extension('mod_spatialite.so')      def dm2dec(self,dms_str):        """Return decimal representation of DM                >>> dms2dec(utf8(48°53.18'N))        48.8866111111F                >>> dm2dec(utf8(2°35.09'E))        2.34330555556F                >>> dms2dec(utf8(48°53'10.18"S))               """                dms_str = re.sub(r'\s', '', dms_str)                sign = -1 if re.search('[swSW]', dms_str) else 1                numbers = [*filter(len, re.split('\D+', dms_str, maxsplit=3))]        degree = numbers[0]        minute = numbers[1] if len(numbers) >= 2 else '0'                frac_seconds = numbers[2] if len(numbers) >= 3 else '0'                minute += "." + frac_seconds        return sign * (int(degree) + float(minute) / 60)        # def latconvert(self):                # s=self.dms2dec(str(self.lineEdit_latitude.text()))        # myProj = Proj("+proj=utm +zone=36 +datum=WGS84 +units=m +no_defs")        # a=myProj(s)        # return a            def longconvert(self):        t=self.dm2dec(str(self.lineEdit_longitude.text()))            s=self.dm2dec(str(self.lineEdit_latitude.text()))        myProj = Proj("+proj=utm +zone=36 +north +datum=WGS84 +units=m +no_defs")        b=myProj(t,s)                #QMessageBox.warning(self, "Test Parametri Quant", str(b),  QMessageBox.Ok)        return str(b).replace(')','')    def insert_point(self):        conn = Connection()        db_url = conn.conn_str()        try:            engine = create_engine(db_url, echo=True)            listen(engine, 'connect', self.load_spatialite)            c = engine.connect()                                            site_point='INSERT INTO shipwreck_location (code,nationality,name_vessel,the_geom) VALUES ("%s", "%s", "%s",(MakePoint %s,32636)));'%( str(self.comboBox_code.currentText()), str(self.comboBox_nationality.currentText()), str(self.comboBox_name_vessel.currentText()),self.longconvert())            c.execute(site_point)                                        except:            pass#QMessageBox.warning(self, "Update error", str(e), QMessageBox.Ok)        def on_pushButtonQuant_pressed(self):        dlg = QuantPanelMain(self)        dlg.insertItems(self.QUANT_ITEMS)        dlg.exec_()        dataset = []        parameter1 = dlg.TYPE_QUANT        parameters2 = dlg.ITEMS        #QMessageBox.warning(self, "Test Parametri Quant", str(parameters2),  QMessageBox.Ok)        contatore = 0        #tipi di quantificazione        ##per forme minime        if parameter1 == 'QTY':            for i in range(len(self.DATA_LIST)):                temp_dataset = ()                try:                    temp_dataset = (self.parameter_quant_creator(parameters2, i), int(self.DATA_LIST[i].qty))                    contatore += int(self.DATA_LIST[i].qty) #conteggio totale                    dataset.append(temp_dataset)                except:                    pass            #QMessageBox.warning(self, "Totale", str(contatore),  QMessageBox.Ok)            if bool(dataset):                dataset_sum = self.UTILITY.sum_list_of_tuples_for_value(dataset)                csv_dataset = []                for sing_tup in dataset_sum:                    sing_list = [sing_tup[0], str(sing_tup[1])]                    csv_dataset.append(sing_list)                filename = ('%s%squant_qty.txt') % (self.QUANT_PATH, os.sep)                #QMessageBox.warning(self, "Esportazione", str(filename), MessageBox.Ok)                f = open(filename, 'wb')                Uw = UnicodeWriter(f)                Uw.writerows(csv_dataset)                f.close()                self.plot_chart(dataset_sum, 'Frequency analisys', 'Qty')            else:                QMessageBox.warning(self, "Warning", "The datas not are present",  QMessageBox.Ok)    def parameter_quant_creator(self, par_list, n_rec):        self.parameter_list = par_list        self.record_number = n_rec        converted_parameters = []        for par in self.parameter_list:            converted_parameters.append(self.CONVERSION_DICT[par])        parameter2 = ''        for sing_par_conv in range(len(converted_parameters)):            exec_str =  ('str(self.DATA_LIST[%d].%s)') % (self.record_number, converted_parameters[sing_par_conv])            paramentro = str(self.parameter_list[sing_par_conv])            exec_str = ' -' + paramentro[:4] + ": " + eval(exec_str)            parameter2 += exec_str        return parameter2    def plot_chart(self, d, t, yl):        self.data_list = d        self.title = t        self.ylabel = yl        if type(self.data_list) == list:            data_diz = {}            for item in self.data_list:                data_diz[item[0]] = item[1]        x = list(range(len(data_diz)))        n_bars = len(data_diz)        values = list(data_diz.values())        teams = list(data_diz.keys())        ind = np.arange(n_bars)        #randomNumbers = random.sample(range(0, 10), 10)        self.widget.canvas.ax.clear()        #QMessageBox.warning(self, "Alert", str(teams) ,  QMessageBox.Ok)        bars = self.widget.canvas.ax.bar(x, height=values, width=0.5, align='center', alpha=0.4,picker=5)        #guardare il metodo barh per barre orizzontali        self.widget.canvas.ax.set_title(self.title)        self.widget.canvas.ax.set_ylabel(self.ylabel)        l = []        for team in teams:            l.append('""')        #self.widget.canvas.ax.set_xticklabels(x , ""   ,size = 'x-small', rotation = 0)        n = 0        for bar in bars:            val = int(bar.get_height())            x_pos = bar.get_x() + 0.25            label  = teams[n]+ ' - ' + str(val)            y_pos = 0.1 #bar.get_height() - bar.get_height() + 1            self.widget.canvas.ax.tick_params(axis='x', labelsize=8)            #self.widget.canvas.ax.set_xticklabels(ind + x, ['fg'], position = (x_pos,y_pos), xsize = 'small', rotation = 90)            self.widget.canvas.ax.text(x_pos, y_pos, label,zorder=0, ha='center', va='bottom',size = 'x-small', rotation = 90)            n+=1        #self.widget.canvas.ax.plot(randomNumbers)        self.widget.canvas.draw()    def enable_button(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_new_search.setEnabled(n)        self.pushButton_search_go.setEnabled(n)        self.pushButton_sort.setEnabled(n)    def enable_button_search(self, n):        self.pushButton_connect.setEnabled(n)        self.pushButton_new_rec.setEnabled(n)        self.pushButton_view_all.setEnabled(n)        self.pushButton_first_rec.setEnabled(n)        self.pushButton_last_rec.setEnabled(n)        self.pushButton_prev_rec.setEnabled(n)        self.pushButton_next_rec.setEnabled(n)        self.pushButton_delete.setEnabled(n)        self.pushButton_save.setEnabled(n)        self.pushButton_sort.setEnabled(n)        self.pushButton_sort.setEnabled(n)        self.pushButton_add.setEnabled(n)        self.pushButton_remove.setEnabled(n)         #self.pushButton_insert_row_video.setEnabled(n)        #self.pushButton_remove_row_video.setEnabled(n)        def on_pushButton_add_pressed(self):        self.insert_new_row('self.tableWidget_list')    def on_pushButton_remove_pressed(self):        self.remove_row('self.tableWidget_list')    def on_pushButton_connect_pressed(self):        """This method establishes a connection between GUI and database"""        conn = Connection()        conn_str = conn.conn_str()        test_conn = conn_str.find('sqlite')        if test_conn == 0:            self.DB_SERVER = "sqlite"        try:            self.DB_MANAGER = Hff_db_management(conn_str)            self.DB_MANAGER.connection()            self.charge_records()  # charge records from DB            # check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = 'b'                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()            else:                QMessageBox.warning(self,"WELCOME HFF user", "Welcome in HFF survey:" + " Shipwreck form." + " The DB is empty. Push 'Ok' and Good Work!",                                    QMessageBox.Ok)                self.charge_list()                self.BROWSE_STATUS = 'x'                self.on_pushButton_new_rec_pressed()        except Exception as e:            e = str(e)            if e.find("no such table"):                msg = "The connection failed {}. " \                      "You MUST RESTART QGIS or bug detected! Report it to the developer".format(str(e))            else:                msg = "Warning bug detected! Report it to the developer. Error: ".format(str(e))                self.iface.messageBar().pushMessage(self.tr(msg), Qgis.Warning, 0)    def charge_list(self):        code_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'code_id', 'SHIPWRECK'))        try:            code_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_code.clear()        code_vl.sort()        self.comboBox_code.addItems(code_vl)                        area_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'area', 'SHIPWRECK'))        try:            area_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in area list: " + str(e), QMessageBox.Ok)                self.comboBox_area.clear()        area_vl.sort()        self.comboBox_area.addItems(area_vl)                        confidence_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'confidence', 'SHIPWRECK'))        try:            confidence_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_confidence.clear()        confidence_vl.sort()        self.comboBox_confidence.addItems(confidence_vl)                                #lista sito        owner_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'owner', 'SHIPWRECK'))        try:            owner_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_owner.clear()        owner_vl.sort()        self.comboBox_owner.addItems(owner_vl)                        #lista sito        nationality_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'nationality', 'SHIPWRECK'))        try:            nationality_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_nationality.clear()        nationality_vl.sort()        self.comboBox_nationality.addItems(nationality_vl)                        #lista sito        builder_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'builder', 'SHIPWRECK'))        try:            builder_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_builder.clear()        builder_vl.sort()        self.comboBox_builder.addItems(builder_vl)                        #lista sito        purpose_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'purpose', 'SHIPWRECK'))        try:            purpose_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_purpose.clear()        purpose_vl.sort()        self.comboBox_purpose.addItems(purpose_vl)                #lista sito        name_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'name_vessel', 'SHIPWRECK'))        try:            name_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_name_vessel.clear()        name_vl.sort()        self.comboBox_name_vessel.addItems(name_vl)                #lista sito        depth_vl = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'depth_quality', 'SHIPWRECK'))        try:            depth_vl.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_quality_depth.clear()        depth_vl.sort()        self.comboBox_quality_depth.addItems(depth_vl)                #lista sito        position_1 = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'position_quality_1', 'SHIPWRECK'))        try:            position_1.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_quality_coordinates.clear()        position_1.sort()        self.comboBox_quality_coordinates.addItems(position_1)                #lista sito        position_2 = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'consulties', 'SHIPWRECK'))        try:            position_2.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_consulties.clear()        position_2.sort()        self.comboBox_consulties.addItems(position_2)                status = self.UTILITY.tup_2_list_III(self.DB_MANAGER.group_by('shipwreck_table', 'status', 'SHIPWRECK'))        try:            status.remove('')        except Exception as e:            if str(e) == "list.remove(x): x not in list":                pass            else:                QMessageBox.warning(self, "Message", "Update system in site list: " + str(e), QMessageBox.Ok)        self.comboBox_status.clear()        status.sort()        self.comboBox_status.addItems(status)    def customize_GUI(self):        # self.tableWidget_foto.setColumnWidth(0, 100)        # self.tableWidget_foto.setColumnWidth(1, 100)        # self.tableWidget_foto.setColumnWidth(2, 100)        # self.tableWidget_foto.setColumnWidth(3, 100)        # self.tableWidget_foto.setColumnWidth(4, 200)        #self.tableWidget_photo.setColumnWidth(1,110)        #self.tableWidget_video.setColumnWidth(1,110)        #media prevew system        #map prevew system        self.mapPreview = QgsMapCanvas(self)        self.mapPreview.setCanvasColor(QColor(225,225,225))        self.tabWidget.addTab(self.mapPreview, "Map")        #media prevew system        #self.iconListWidget = QtGui.QListWidget(self)        #self.iconListWidget.setFrameShape(QtGui.QFrame.StyledPanel)        #self.iconListWidget.setFrameShadow(QtGui.QFrame.Sunken)        self.iconListWidget.setLineWidth(2)        self.iconListWidget.setMidLineWidth(2)        self.iconListWidget.setProperty("showDropIndicator", False)        self.iconListWidget.setIconSize(QSize(620, 590))        self.iconListWidget.setMovement(QListView.Snap)        self.iconListWidget.setResizeMode(QListView.Adjust)        self.iconListWidget.setLayoutMode(QListView.Batched)        #self.iconListWidget.setGridSize(QtCore.QSize(2000, 1000))        #self.iconListWidget.setViewMode(QtGui.QListView.IconMode)        self.iconListWidget.setUniformItemSizes(True)        #self.iconListWidget.setBatchSize(1500)        self.iconListWidget.setObjectName("iconListWidget")        self.iconListWidget.SelectionMode()        self.iconListWidget.setSelectionMode(QAbstractItemView.SingleSelection)        self.iconListWidget.itemDoubleClicked.connect(self.openWide_image)            # def loadMedialist(self):        # self.tableWidget_foto.clear()        # col =['Nationality','Code ID','Name Vessel','Nickname']        # self.tableWidget_foto.setHorizontalHeaderLabels(col)        # numRows = self.tableWidget_foto.setRowCount(1000)        # try:             # search_dict = {                # 'nationality': "'" + str(eval("self.DATA_LIST[int(self.REC_CORR)]. " + self.ID_SITO)) + "'"}            # record_us_list = self.DB_MANAGER.query_bool(search_dict, 'SHIPWRECK')            # nus=0            # for b in record_us_list:                # if nus== 0:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.nationality)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.code_id)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.name_vessel)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.nickname)))                        # nus+=1                # else:                    # self.tableWidget_foto.setItem(nus, 0, QTableWidgetItem(str(b.nationality)))                                        # self.tableWidget_foto.setItem(nus, 1, QTableWidgetItem(str(b.code_id)))                                        # self.tableWidget_foto.setItem(nus, 2, QTableWidgetItem(str(b.name_vessel)))                                        # self.tableWidget_foto.setItem(nus, 3, QTableWidgetItem(str(b.nickname)))                      # nus+=1         # except:            # pass                           def listview_us(self):        if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()            conn_sqlite = conn.databasename()            conn_user = conn.datauser()            conn_host = conn.datahost()            conn_port = conn.dataport()            port_int  = conn_port["port"]            port_int.replace("'", "")            conn_password = conn.datapassword()            #sito_set= conn.sito_set()            #sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            if test_conn == 0:                sqlite_DB_path = '{}{}{}'.format(self.HOME, os.sep,                                               "HFF_DB_folder")                 db = QSqlDatabase("QSQLITE")                 db.setDatabaseName(sqlite_DB_path +os.sep+ conn_sqlite["db_name"])                db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                 self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                column_titles = {                     #"site":"SITE",                    "code_id": "CODE ID"}                     #"years": "YEAR"}                 for n, t in column_titles.items():                     idx = self.model_a.fieldIndex( n)                     self.model_a.setHeaderData( idx, Qt.Horizontal, t)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                 # else:                self.model_a.select()             else:                db = QSqlDatabase.addDatabase("QPSQL")                db.setHostName(conn_host["host"])                db.setDatabaseName(conn_sqlite["db_name"])                db.setPort(int(port_int))                db.setUserName(conn_user['user'])                db.setPassword(conn_password['password'])                 db.open()                self.model_a = QSqlTableModel(db = db)                 self.table.setModel(self.model_a)                 self.model_a.setTable(self.TABLE_NAME)                self.model_a.setEditStrategy(QSqlTableModel.OnManualSubmit)                self.pushButton_submit.clicked.connect(self.submit)                self.pushButton_revert.clicked.connect(self.model_a.revertAll)                # if bool (sito_set_str):                    # filter_str = "site = '{}'".format(str(self.comboBox_sito.currentText()))                     # self.model_a.setFilter(filter_str)                    # self.model_a.select()                # else:                self.model_a.select()         else:            self.checkBox_query.setChecked(False)    def submit(self):        if self.checkBox_query.isChecked():            self.model_a.database().transaction()            if self.model_a.submitAll():                self.model_a.database().commit()                if self.L=='it':                    QMessageBox.information(self, "Record",  "record salvato")                elif self.L=='de':                    QMessageBox.information(self, "Datensatz",  "Datensatz gespeichert")                else:                    QMessageBox.information(self, "Record",  "record saved")                        else:                self.model_a.database().rollback()                if self.L=='it':                    QMessageBox.warning(self, "Cached Table",                            "Il db ha segnalato un errore: %s" % self.model_a.lastError().text())                            elif self.L=='de':                    QMessageBox.warning(self, "Cached Table",                            "Die Datenbank meldete einen Fehler: %s" % self.model_a.lastError().text())                                                else:                    QMessageBox.warning(self, "Cached Table",                            "The database reported an error: %s" % self.model_a.lastError().text())                                else:                self.checkBox_query.setChecked(False)    def update_filter(self, s):         if self.checkBox_query.isChecked():            conn = Connection()            conn_str = conn.conn_str()                # sito_set= conn.sito_set()            # sito_set_str = sito_set['sito_set']            test_conn = conn_str.find('sqlite')            s_field = self.field.currentText()            s = re.sub("[\W_] +", "", s)            if test_conn == 0:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                         # self.model_a.setFilter(filter_str)                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     self.model_a.setFilter(filter_str)                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)            else:                try:                    # if bool(sito_set_str):                        # filter_str = "{} LIKE '%{}%' and site = '{}'".format(s_field,s,str(self.comboBox_sito.currentText()))                        # if bool(filter_str):                            # self.model_a.setFilter(filter_str)                            # self.model_a.select()                        # else:                            # pass                    # else:                    filter_str = "{} LIKE '%{}%'".format(s_field,s)                     if bool(filter_str):                        self.model_a.setFilter(filter_str)                        self.model_a.select()                     else:                        pass                except Exception as e:                    QMessageBox.warning(self, "Warning", str(e), QMessageBox.Ok)        else:                self.checkBox_query.setChecked(False)        def on_pushButton_go_to_scheda_pressed(self):        if self.L=='it':            QMessageBox.warning(self, "ATTENZIONE", "Se hai modificato il record e non lo hai salvato perderai il dato. Salvare?", QMessageBox.Ok | QMessageBox.Cancel)        else:            QMessageBox.warning(self, "Warning", "If you changed the record and didn't save it, you'll lose the record. Do you want save it?", QMessageBox.Ok | QMessageBox.Cancel)                # try:            # table_name = "self.tableWidget_foto"            # rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            # rowSelected = eval(rowSelected_cmd)            # rowIndex = (rowSelected[0].row())            # site = str(self.comboBox_site.currentText())            # year = str(self.comboBox_years.currentText())            # us_item = self.tableWidget_foto.item(rowIndex, 3)            # divelog_id = str(us_item.text())            # search_dict = {                           # 'divelog_id':  "'" + str(divelog_id) + "'"}            # u = Utility()            # search_dict = u.remove_empty_items_fr_dict(search_dict)            # res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                        # if not bool(res):                                # if self.L=='it':                    # QMessageBox.warning(self, "ATTENZIONE", "Non e' stato trovato alcun record!", QMessageBox.Ok)                # elif self.L=='de':                    # QMessageBox.warning(self, "ACHTUNG", "kein Eintrag gefunden!", QMessageBox.Ok)                # else:                    # QMessageBox.warning(self, "Warning", "The record has not been found ", QMessageBox.Ok)                # self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                # self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                # self.fill_fields(self.REC_CORR)                # self.BROWSE_STATUS = "b"                # self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                # self.setComboBoxEnable(["self.comboBox_site"], "False")                # self.setComboBoxEnable(["self.comboBox_years"], "False")                # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "False")            # else:                # self.empty_fields()                # self.DATA_LIST = []                # for i in res:                    # self.DATA_LIST.append(i)                # self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                # self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                # self.fill_fields()                # self.BROWSE_STATUS = "b"                # self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                # self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                # if self.REC_TOT == 1:                                                            # if self.L=='it':                        # strings = ("E' stato trovato", self.REC_TOT, "record")                    # elif self.L=='de':                        # strings = ("Es wurde gefunden", self.REC_TOT, "record")                    # else:                        # strings = ("has been found", self.REC_TOT, "record")                    # # if self.toolButtonGis.isChecked():                        # # self.pyQGIS.charge_vector_layers(self.DATA_LIST)                # else:                                        # if self.L=='it':                        # strings = ("Sono stati trovati", self.REC_TOT, "records")                    # elif self.L=='de':                        # strings = ("Sie wurden gefunden", self.REC_TOT, "records")                    # else:                        # strings = ("Have been found", self.REC_TOT, "records")                    # # if self.toolButtonGis.isChecked():                        # # self.pyQGIS.charge_vector_layers(self.DATA_LIST)                # self.setComboBoxEnable(["self.comboBox_site"], "False")                # self.setComboBoxEnable(["self.comboBox_years"], "False")                # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "False")        # except Exception as e:            # e = str(e)            # if self.L=='it':                # QMessageBox.warning(self, "Alert", "Non hai selezionato nessuna riga. Errore python: %s " % (str(e)),                                # QMessageBox.Ok)            # elif self.L=='de':                # QMessageBox.warning(self, "ACHTUNG", "Keine Spalte ausgewält. Error python: %s " % (str(e)),                                # QMessageBox.Ok)            # else:                # QMessageBox.warning(self, "Alert", "You didn't select any row. Python error: %s " % (str(e)),                                # QMessageBox.Ok)        try:            #table_name = "self.table"            #rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)            rowSelected = self.table.currentIndex()#eval(rowSelected_cmd)            rowIndex = rowSelected.row()            #sito_item = self.table.model().index(rowIndex,31)            code_item = self.table.model().index(rowIndex,1)            #us = str(self.lineEdit_us.text())            #us_item = self.table.model().index(rowIndex,27)            #for i in us_item:            #sito =self.table.model().data(sito_item)            code_id= self.table.model().data(code_item)            #years = self.table.model().data(us_item)            search_dict = {#'site': "'" + str(sito) + "'",                           'code_id': "'" + str(code_id) + "'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)            self.empty_fields()            self.DATA_LIST = []            for i in res:                self.DATA_LIST.append(i)            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.fill_fields()            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)        except Exception as e:            e = str(e)            if self.L=='it':                QMessageBox.warning(self, "Alert", "Non hai selezionato nessuna riga. Errore python: %s " % (str(e)),                                QMessageBox.Ok)            elif self.L=='de':                QMessageBox.warning(self, "ACHTUNG", "Keine Spalte ausgewält. Error python: %s " % (str(e)),                                QMessageBox.Ok)            else:                QMessageBox.warning(self, "Alert", "You didn't select any row. Python error: %s " % (str(e)),                                QMessageBox.Ok)       def on_toolButtonPreview_toggled(self):        if self.toolButtonPreview.isChecked() == True:            QMessageBox.warning(self, "Message", "Shipwreck Preview mode attivata. The plnas will be shown in the map section", QMessageBox.Ok)            self.loadMapPreview()        else:            self.loadMapPreview(1)    def on_toolButtonPreviewMedia_toggled(self):        if self.toolButtonPreviewMedia.isChecked() == True:            QMessageBox.warning(self, "Message",                                    "Shipwreck Media Preview mode enabled. Anchor images will be displayed in the Media section", QMessageBox.Ok)            self.loadMediaPreview()        else:            self.loadMediaPreview(1)     def loadMapPreview(self, mode = 0):        if mode == 0:            """ if has geometry column load to map canvas """            gidstr =  self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            layerToSet = self.pyQGIS.loadMapPreview(gidstr)            #QMessageBox.warning(self, "layer to set", str(layerToSet), QMessageBox.Ok)            self.mapPreview.setPreviewModeEnabled            self.mapPreview.setLayerSet(layerToSet)            self.mapPreview.zoomToFullExtent()            self.mapPreview.refresh()        elif mode == 1:            self.mapPreview.setLayerSet( [ ] )            self.mapPreview.zoomToFullExtent()    def loadMediaPreview(self, mode = 0):        self.iconListWidget.clear()        conn = Connection()                thumb_path = conn.thumb_path()        thumb_path_str = thumb_path['thumb_path']                if mode == 0:            """ if has geometry column load to map canvas """            rec_list =  self.ID_TABLE + " = " + str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))            search_dict = {'id_entity'  : "'"+str(eval("self.DATA_LIST[int(self.REC_CORR)]." + self.ID_TABLE))+"'", 'entity_type' : "'SHIPWRECK'"}            record_doc_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIATOENTITY')            for i in record_doc_list:                search_dict = {'id_media' : "'"+str(i.id_media)+"'"}                u = Utility()                search_dict = u.remove_empty_items_fr_dict(search_dict)                mediathumb_data = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                thumb_path = str(mediathumb_data[0].filepath)                item = QListWidgetItem(str(i.media_name))                item.setData(Qt.UserRole,str(i.media_name))                icon = QIcon(thumb_path_str+thumb_path)                item.setIcon(icon)                self.iconListWidget.addItem(item)        elif mode == 1:            self.iconListWidget.clear()    def openWide_image(self):        items = self.iconListWidget.selectedItems()        conn = Connection()        conn_str = conn.conn_str()        thumb_resize = conn.thumb_resize()        thumb_resize_str = thumb_resize['thumb_resize']        for item in items:            dlg = ImageViewer()            id_orig_item = item.text()  # return the name of original file            search_dict = {'media_filename': "'" + str(id_orig_item) + "'", 'mediatype': "'" + 'video' + "'"}            u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)                        res = self.DB_MANAGER.query_bool(search_dict, "MEDIA_THUMB")                                    search_dict_2 = {'media_filename': "'" + str(id_orig_item) + "'", 'mediatype': "'" + 'image' + "'"}                        search_dict_2 = u.remove_empty_items_fr_dict(search_dict_2)                        res_2 = self.DB_MANAGER.query_bool(search_dict_2, "MEDIA_THUMB")                        search_dict_3 = {'media_filename': "'" + str(id_orig_item) + "'"}                          search_dict_3 = u.remove_empty_items_fr_dict(search_dict_3)                        res_3 = self.DB_MANAGER.query_bool(search_dict_3, "MEDIA_THUMB")                        file_path_3 = str(res_3[0].path_resize)            if bool(res):                            os.startfile(str(thumb_resize_str+file_path_3))            else:                pass            if bool(res_2):                dlg.show_image(str(thumb_resize_str+file_path_3))                  dlg.exec_()            else:                pass    def on_pushButton_sort_pressed(self):        if self.check_record_state() == 1:            pass        else:            dlg = SortPanelMain(self)            dlg.insertItems(self.SORT_ITEMS)            dlg.exec_()            items,order_type = dlg.ITEMS, dlg.TYPE_ORDER            self.SORT_ITEMS_CONVERTED = []            for i in items:                #QMessageBox.warning(self, "Messaggio",i, QMessageBox.Ok)                self.SORT_ITEMS_CONVERTED.append(self.CONVERSION_DICT[str(i)]) #apportare la modifica nellle altre schede            self.SORT_MODE = order_type            self.empty_fields()            id_list = []            for i in self.DATA_LIST:                id_list.append(eval("i." + self.ID_TABLE))            self.DATA_LIST = []            temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE, self.MAPPER_TABLE_CLASS, self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)            self.BROWSE_STATUS = "b"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            if type(self.REC_CORR) == "<type 'str'>":                corr = 0            else:                corr = self.REC_CORR            self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0            self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]            self.SORT_STATUS = "o"            self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])            self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)            self.fill_fields()    def on_pushButton_new_rec_pressed(self):        if bool(self.DATA_LIST):            if self.data_error_check() == 1:                pass            else:                if self.BROWSE_STATUS == "b":                    if self.DATA_LIST:                        if self.records_equal_check() == 1:                            self.update_if(QMessageBox.warning(self, 'Error',                                                               "The record has been changed. Do you want to save the changes?",                                                               QMessageBox.Ok | QMessageBox.Cancel))                            # set the GUI for a new record        if self.BROWSE_STATUS != "n":            self.BROWSE_STATUS = "n"            self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])            self.empty_fields()            self.label_sort.setText(self.SORTED_ITEMS["n"])            # self.setComboBoxEnable(["self.comboBox_code"], "True")            # self.setComboBoxEditable(["self.comboBox_code"], 1)            # self.setComboBoxEnable(["self.comboBox_years"], "True")            # self.setComboBoxEditable(["self.comboBox_type"], 1)            # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "True")            self.set_rec_counter('', '')            self.enable_button(0)    def on_pushButton_save_pressed(self):                        if self.BROWSE_STATUS == "b":            if self.data_error_check() == 0:                if self.records_equal_check() == 1:                    self.update_if(QMessageBox.warning(self, 'Error',                                                       "The record has been changed. Do you want to save the changes?",                                                       QMessageBox.Ok | QMessageBox.Cancel))                                                            self.insert_point()                    self.empty_fields()                    self.SORT_STATUS = "n"                    self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])                    self.enable_button(1)                    self.fill_fields(self.REC_CORR)                                    else:                    QMessageBox.warning(self, "Warning", "No changes have been made", QMessageBox.Ok)        else:            if self.data_error_check() == 0:                test_insert = self.insert_new_rec()                if test_insert == 1:                                                            self.insert_point()                    self.empty_fields()                    self.label_sort.setText(self.SORTED_ITEMS["n"])                    self.charge_list()                    self.charge_records()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                    # self.setComboBoxEnable(["self.comboBox_code"], "True")                    # self.setComboBoxEditable(["self.comboBox_code"], 1)                    # self.setComboBoxEnable(["self.comboBox_years"], "True")                    # self.setComboBoxEditable(["self.comboBox_type"], 1)                    # self.setComboBoxEnable(["self.lineEdit_divelog_id"], "True")                    self.fill_fields(self.REC_CORR)                                        self.enable_button(1)                else:                    pass    def insert_new_rec(self):        list = self.table2dict("self.tableWidget_list")                if self.lineEdit_l.text() == "":            l_a = None        else:            l_a= float(self.lineEdit_l.text())        if self.lineEdit_w.text() == "":            w_a = None        else:            w_a = float(self.lineEdit_w.text())        if self.lineEdit_d.text() == "":            d_a = None        else:            d_a = float(self.lineEdit_d.text())        if self.lineEdit_t.text() == "":            t_a = None        else:            t_a = float(self.lineEdit_t.text())        if self.lineEdit_cl.text() == "":            cl_a = None        else:            cl_a = float(self.lineEdit_cl.text())        if self.lineEdit_cw.text() == "":            cw_a = None        else:            cw_a = float(self.lineEdit_cw.text())         if self.lineEdit_cd.text() == "":            cd_a = None        else:            cd_a = float(self.lineEdit_cd.text())                   try:            #data            data = self.DB_MANAGER.insert_shipwreck_values(            self.DB_MANAGER.max_num_id(self.MAPPER_TABLE_CLASS, self.ID_TABLE)+1,            str(self.comboBox_code.currentText()),            str(self.comboBox_name_vessel.currentText()),            str(self.lineEdit_yard.text()),            str(self.comboBox_area.currentText()),            str(self.comboBox_category.currentText()),            str(self.comboBox_confidence.currentText()),            str(self.comboBox_propulsion.currentText()),            str(self.comboBox_material.currentText()),            str(self.comboBox_nationality.currentText()),            str(self.comboBox_type.currentText()),            str(self.comboBox_owner.currentText()),            str(self.comboBox_purpose.currentText()),            str(self.comboBox_builder.currentText()),            str(self.comboBox_cause.currentText()),            str(self.comboBox_divers.currentText()),            str(self.comboBox_wreck.currentText()),            str(self.comboBox_composition.currentText()),            str(self.comboBox_inclination.currentText()),            str(self.lineEdit_depth.text()),            str(self.comboBox_quality_depth.currentText()),            str(self.lineEdit_latitude.text()),            str(self.comboBox_quality_coordinates.currentText()),            str(self.lineEdit_longitude.text()),            str(self.comboBox_consulties.currentText()),            l_a,            w_a,            d_a,            t_a,            cl_a,            cw_a,            cd_a,            str(self.lineEdit_nickname.text()),            str(self.lineEdit_date_built.text()),            str(self.lineEdit_date_lost.text()),            str(self.textEdit_description.toPlainText()),            str(self.textEdit_history.toPlainText()),            str(list),            str(self.comboBox_name.currentText()),            str(self.comboBox_status.currentText()))            try:                self.DB_MANAGER.insert_data_session(data)                return 1            except Exception as e:                e_str = str(e)                if e_str.__contains__("IntegrityError"):                    msg = self.ID_TABLE + " exist in db"                    QMessageBox.warning(self, "Error", "Error" + str(msg), QMessageBox.Ok)                  else:                    msg = e                    QMessageBox.warning(self, "Error", "Error 1 \n" + str(msg), QMessageBox.Ok)                return 0        except Exception as e:            QMessageBox.warning(self, "Error", "Error 2 \n" + str(e), QMessageBox.Ok)            return 0    def check_record_state(self):        ec = self.data_error_check()        if ec == 1:            return 1 #ci sono errori di immissione        elif self.records_equal_check() == 1 and ec == 0:            #self.update_if#(QMessageBox.warning(self,'Errore',"Il record e' stato modificato. Vuoi salvare le modifiche?", QMessageBox.Cancel,1))            #self.charge_records()            return 0 #non ci sono errori di immissione    #records surf functions    def on_pushButton_view_all_pressed(self):        self.empty_fields()        self.charge_records()        self.fill_fields()        self.BROWSE_STATUS = "b"        self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])        if type(self.REC_CORR) == "<class 'str'>":            corr = 0        else:            corr = self.REC_CORR        self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)        self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0        self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])        # records surf functions    #records surf functions    def on_pushButton_first_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.fill_fields(0)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except Exception as e:                QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_last_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            try:                self.empty_fields()                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), len(self.DATA_LIST) - 1                self.fill_fields(self.REC_CORR)                self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)            except Exception as e:                QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def data_error_check(self):        test = 0        EC = Error_check()        if EC.data_is_empty(str(self.comboBox_code.currentText())) == 0:            QMessageBox.warning(self, "Warning", "Code field. \n This field cannot be empty",  QMessageBox.Ok)            test = 1        return test     def on_pushButton_prev_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR - 1            if self.REC_CORR == -1:                self.REC_CORR = 0                QMessageBox.warning(self, "Warning", "You are to the first record!", QMessageBox.Ok)                    else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                except Exception as e:                    QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_next_rec_pressed(self):        if self.check_record_state() == 1:            pass        else:            self.REC_CORR = self.REC_CORR + 1            if self.REC_CORR >= self.REC_TOT:                self.REC_CORR = self.REC_CORR - 1                QMessageBox.warning(self, "Error", "You are to the first record!", QMessageBox.Ok)              else:                try:                    self.empty_fields()                    self.fill_fields(self.REC_CORR)                    self.set_rec_counter(self.REC_TOT, self.REC_CORR + 1)                except Exception as e:                    QMessageBox.warning(self, "Error", str(e), QMessageBox.Ok)    def on_pushButton_delete_pressed(self):        msg = QMessageBox.warning(self,"Warning!!!","Do you really want to delete the record? \n The action is irreversible", QMessageBox.Ok|QMessageBox.Cancel)        if msg == QMessageBox.Cancel:            QMessageBox.warning(self,"Message!!!","Action cancelled!")        else:            try:                id_to_delete = eval("self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE)                self.DB_MANAGER.delete_one_record(self.TABLE_NAME, self.ID_TABLE, id_to_delete)                self.charge_records() #charge records from DB                QMessageBox.warning(self,"Message!!!","Record deleted!")            except Exception as e:                QMessageBox.warning(self,"Message!!!","Type of Error: "+str(e))            if not bool(self.DATA_LIST):                QMessageBox.warning(self, "Warning", "The database is empty!",  QMessageBox.Ok)                self.DATA_LIST = []                self.DATA_LIST_REC_CORR = []                self.DATA_LIST_REC_TEMP = []                self.REC_CORR = 0                self.REC_TOT = 0                self.empty_fields()                self.set_rec_counter(0, 0)            #check if DB is empty            if bool(self.DATA_LIST):                self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                self.charge_list()                self.fill_fields()        self.SORT_STATUS = "n"        self.label_sort.setText(self.SORTED_ITEMS[self.SORT_STATUS])    def on_pushButton_new_search_pressed(self):        if self.BROWSE_STATUS != "f" and self.check_record_state() == 1:            pass        else:            self.enable_button_search(0)            #set the GUI for a new search            if self.BROWSE_STATUS != "f":                self.BROWSE_STATUS = "f"                ###                # self.setComboBoxEnable(["self.comboBox_artefact"],"True")                # self.setComboBoxEditable(["self.comboBox_artefact"],1)                # self.setComboBoxEnable(["self.lineEdit_divelog_id"],"True")                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                self.set_rec_counter('', '')                self.label_sort.setText(self.SORTED_ITEMS["n"])                self.charge_list()                self.empty_fields()    def on_pushButton_showLayer_pressed(self):        """        for sing_us in range(len(self.DATA_LIST)):            sing_layer = [self.DATA_LIST[sing_us]]            self.pyQGIS.charge_vector_layers(sing_layer)        """        sing_layer = [self.DATA_LIST[self.REC_CORR]]        self.pyQGIS.charge_shipwreck_layers(sing_layer)    def on_toolButtonGis_toggled(self):        if self.toolButtonGis.isChecked() == True:            QMessageBox.warning(self, "Message", "GIS mode activated. From now on what you search will be shown in GIS", QMessageBox.Ok)        else:            QMessageBox.warning(self, "Message", "GIS mode deactivated. From now on what you search will not be shown in GIS", QMessageBox.Ok)    def on_pushButton_search_go_pressed(self):        if self.BROWSE_STATUS != "f":            QMessageBox.warning(self, "Warning", "To carry out a new search click on the 'new search' button",  QMessageBox.Ok)        else:            #TableWidget                                                if self.lineEdit_l.text() != "":                l= float(self.lineEdit_l.text())            else:                l = None            if self.lineEdit_w.text() != "":                w = float(self.lineEdit_w.text())            else:                w = None            if self.lineEdit_d.text() != "":                d = float(self.lineEdit_d.text())            else:                d = None            if self.lineEdit_t.text() != "":                t = float(self.lineEdit_t.text())            else:                t = None            if self.lineEdit_cl.text() != "":                cl = float(self.lineEdit_cl.text())            else:                cl = None            if self.lineEdit_cw.text() != "":                cw = float(self.lineEdit_cw.text())            else:                cw = None               if self.lineEdit_cd.text() != "":                cd = float(self.lineEdit_cd.text())               else:                cd = None                             search_dict = {            self.TABLE_FIELDS[0]  : "'"+str(self.comboBox_code.currentText())+"'",            self.TABLE_FIELDS[1]  : "'"+str(self.comboBox_name_vessel.currentText())+"'",  #2 - Area            self.TABLE_FIELDS[2]  : "'"+str(self.lineEdit_yard.text())+"'",  #2 - Area            self.TABLE_FIELDS[3]  : "'"+str(self.comboBox_area.currentText())+"'",            self.TABLE_FIELDS[4]  : "'"+str(self.comboBox_category.currentText())+"'",            self.TABLE_FIELDS[5]  : "'"+str(self.comboBox_confidence.currentText())+"'",#3 - US            self.TABLE_FIELDS[6]  : "'"+str(self.comboBox_propulsion.currentText())+"'",                                             self.TABLE_FIELDS[7]  : "'"+str(self.comboBox_material.currentText())+"'",                                   #6 - descrizione            self.TABLE_FIELDS[8]  : "'"+str(self.comboBox_nationality.currentText())+"'",                                   #7 - interpretazione            self.TABLE_FIELDS[9]  : "'"+str(self.comboBox_type.currentText())+"'",            self.TABLE_FIELDS[10]  : "'"+str(self.comboBox_owner.currentText())+"'",            self.TABLE_FIELDS[11]  : "'"+str(self.comboBox_purpose.currentText())+"'",            self.TABLE_FIELDS[12]  : "'"+str(self.comboBox_builder.currentText())+"'",            self.TABLE_FIELDS[13]  : "'"+str(self.comboBox_cause.currentText())+"'",            self.TABLE_FIELDS[14]  : "'"+str(self.comboBox_divers.currentText())+"'",            self.TABLE_FIELDS[15]  : "'"+str(self.comboBox_wreck.currentText())+"'",            self.TABLE_FIELDS[16]  : "'"+str(self.comboBox_composition.currentText())+"'",            self.TABLE_FIELDS[17]  : "'"+str(self.comboBox_inclination.currentText())+"'",            self.TABLE_FIELDS[18]  : "'"+str(self.lineEdit_depth.text())+"'",             self.TABLE_FIELDS[19]  : "'"+str(self.comboBox_quality_depth.currentText())+"'",            self.TABLE_FIELDS[20]  : "'"+str(self.lineEdit_latitude.text())+"'",             self.TABLE_FIELDS[21]  : "'"+str(self.comboBox_quality_coordinates.currentText())+"'",            self.TABLE_FIELDS[22]  : "'"+str(self.lineEdit_longitude.text())+"'",             self.TABLE_FIELDS[23]  : "'"+str(self.comboBox_consulties.currentText())+"'",            self.TABLE_FIELDS[24]  : l,            self.TABLE_FIELDS[25]  : w,            self.TABLE_FIELDS[26]  : d,            self.TABLE_FIELDS[27]  : t,            self.TABLE_FIELDS[28]  : cl,            self.TABLE_FIELDS[29]  : cw,            self.TABLE_FIELDS[30]  : cd,            self.TABLE_FIELDS[31]  : "'"+str(self.lineEdit_nickname.text())+"'",  #2 - Area            self.TABLE_FIELDS[32]  : "'"+str(self.lineEdit_date_built.text())+"'",  #2 - Area            self.TABLE_FIELDS[33]  : "'"+str(self.lineEdit_date_lost.text())+"'",  #2 - Area            self.TABLE_FIELDS[34]  : str(self.textEdit_description.toPlainText()),            self.TABLE_FIELDS[35]  : str(self.textEdit_history.toPlainText()),            self.TABLE_FIELDS[37]  : "'"+str(self.comboBox_name.currentText())+"'",            self.TABLE_FIELDS[38]  : "'"+str(self.comboBox_status.currentText())+"'"            }               u = Utility()            search_dict = u.remove_empty_items_fr_dict(search_dict)            if not bool(search_dict):                QMessageBox.warning(self, "Warning",  "No search has been set!!!",  QMessageBox.Ok)            else:                res = self.DB_MANAGER.query_bool(search_dict, self.MAPPER_TABLE_CLASS)                if not bool(res):                    QMessageBox.warning(self, "Warning", "No record has been found",  QMessageBox.Ok)                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR+1)                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields(self.REC_CORR)                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.setComboBoxEnable(["self.comboBox_code"],"True")                                        self.fill_fields(self.REC_CORR)                else:                    self.DATA_LIST = []                    for i in res:                        self.DATA_LIST.append(i)                    self.REC_TOT, self.REC_CORR = len(self.DATA_LIST), 0                    self.DATA_LIST_REC_TEMP = self.DATA_LIST_REC_CORR = self.DATA_LIST[0]                    self.fill_fields()                    self.BROWSE_STATUS = "b"                    self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                    self.set_rec_counter(len(self.DATA_LIST), self.REC_CORR + 1)                    if self.REC_TOT == 1:                        strings = ("It has been found", self.REC_TOT, "record")                        if self.toolButtonGis.isChecked():                            self.pyQGIS.charge_shipwreck_layers(self.DATA_LIST)                    else:                        strings = ("They have been found", self.REC_TOT, "records")                        if self.toolButtonGis.isChecked():                            self.pyQGIS.charge_shipwreck_layers(self.DATA_LIST)                    #self.setComboBoxEnable(["self.comboBox_diver"],"True")                    self.setComboBoxEnable(["self.comboBox_code"],"True")                                                            #self.setComboBoxEnable(["self.lineEdit_divelog_id"],"True")                    #self.setComboBoxEditable(["self.lineEdit_years"],"True")                    #self.setComboBoxEnable(["self.lineEdit_years"],"True")                    #self.setTableEnable(["self.tableWidget_photo", "self.tableWidget_video"], "True")                    check_for_buttons = 1                    QMessageBox.warning(self, "Messaggio", "%s %d %s" % strings, QMessageBox.Ok)        self.enable_button_search(1)    def update_if(self, msg):        rec_corr = self.REC_CORR        if msg == QMessageBox.Ok:            test = self.update_record()            if test == 1:                id_list = []                for i in self.DATA_LIST:                    id_list.append(eval("i." + self.ID_TABLE))                self.DATA_LIST = []                if self.SORT_STATUS == "n":                    temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc',                                                                self.MAPPER_TABLE_CLASS,                                                                self.ID_TABLE)  # self.DB_MANAGER.query_bool(self.SEARCH_DICT_TEMP, self.MAPPER_TABLE_CLASS) #                else:                    temp_data_list = self.DB_MANAGER.query_sort(id_list, self.SORT_ITEMS_CONVERTED, self.SORT_MODE,                                                                self.MAPPER_TABLE_CLASS, self.ID_TABLE)                for i in temp_data_list:                    self.DATA_LIST.append(i)                self.BROWSE_STATUS = "b"                self.label_status.setText(self.STATUS_ITEMS[self.BROWSE_STATUS])                if type(self.REC_CORR) == "<type 'str'>":                    corr = 0                else:                    corr = self.REC_CORR                return 1            elif test == 0:                return 0    def update_record(self):        try:            self.DB_MANAGER.update(self.MAPPER_TABLE_CLASS,                                   self.ID_TABLE,                                   [eval("int(self.DATA_LIST[self.REC_CORR]." + self.ID_TABLE + ")")],                                   self.TABLE_FIELDS,                                   self.rec_toupdate())            return 1        except Exception as e:            QMessageBox.warning(self, "Message", "Encoding problem: accents or characters that are not accepted by the database have been inserted. If you close the window without correcting the errors the data will be lost. Create a copy of everything on a seperate word document. Error :" + str(e), QMessageBox.Ok)            return 0    def rec_toupdate(self):        rec_to_update = self.UTILITY.pos_none_in_list(self.DATA_LIST_REC_TEMP)        return rec_to_update        # custom functions    def charge_records(self):        self.DATA_LIST = []        if self.DB_SERVER == 'sqlite':            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                self.DATA_LIST.append(i)        else:            id_list = []            for i in self.DB_MANAGER.query(self.MAPPER_TABLE_CLASS):                id_list.append(eval("i." + self.ID_TABLE))            temp_data_list = self.DB_MANAGER.query_sort(id_list, [self.ID_TABLE], 'asc', self.MAPPER_TABLE_CLASS,                                                        self.ID_TABLE)            for i in temp_data_list:                self.DATA_LIST.append(i)    def datestrfdate(self):        now = date.today()        today = now.strftime("%d-%m-%Y")        return today    def yearstrfdate(self):        now = date.today()        year = now.strftime("%Y")        return year    def table2dict(self, n):        self.tablename = n        row = eval(self.tablename + ".rowCount()")        col = eval(self.tablename + ".columnCount()")        lista = []        for r in range(row):            sub_list = []            for c in range(col):                value = eval(self.tablename + ".item(r,c)")                if value != None:                    sub_list.append(str(value.text()))            if bool(sub_list):                lista.append(sub_list)        return lista    def tableInsertData(self, t, d):        """Set the value into alls Grid"""        self.table_name = t        self.data_list = eval(d)        self.data_list.sort()        # column table count        table_col_count_cmd = "{}.columnCount()".format(self.table_name)        table_col_count = eval(table_col_count_cmd)        # clear table        table_clear_cmd = "{}.clearContents()".format(self.table_name)        eval(table_clear_cmd)        for i in range(table_col_count):            table_rem_row_cmd = "{}.removeRow(int({}))".format(self.table_name, i)            eval(table_rem_row_cmd)            # for i in range(len(self.data_list)):            # self.insert_new_row(self.table_name)        for row in range(len(self.data_list)):            cmd = '{}.insertRow(int({}))'.format(self.table_name, row)            eval(cmd)            for col in range(len(self.data_list[row])):                # item = self.comboBox_code.setEditText(self.data_list[0][col]                # item = QTableWidgetItem(self.data_list[row][col])                # TODO SL: evauation of QTableWidget does not work porperly                exec_str = '{}.setItem(int({}),int({}),QTableWidgetItem(self.data_list[row][col]))'.format(self.table_name, row, col)                eval(exec_str)    def insert_new_row(self, table_name):        """insert new row into a table based on table_name"""        cmd = table_name + ".insertRow(0)"        eval(cmd)    def remove_row(self, table_name):        """insert new row into a table based on table_name"""        table_row_count_cmd = ("%s.rowCount()") % (table_name)        table_row_count = eval(table_row_count_cmd)        rowSelected_cmd = ("%s.selectedIndexes()") % (table_name)        rowSelected = eval(rowSelected_cmd)        rowIndex = (rowSelected[0].row())        cmd = ("%s.removeRow(%d)") % (table_name, rowIndex)        eval(cmd)    def empty_fields(self):        list = self.tableWidget_list.rowCount()        self.comboBox_code.setEditText("")        self.comboBox_name_vessel.setEditText("")        self.lineEdit_yard.clear()        self.comboBox_area.setEditText("")        self.comboBox_category.setEditText("")        self.comboBox_confidence.setEditText("")        self.comboBox_propulsion.setEditText("")        self.comboBox_material.setEditText("")        self.comboBox_nationality.setEditText("")        self.comboBox_type.setEditText("")        self.comboBox_owner.setEditText("")        self.comboBox_purpose.setEditText("")        self.comboBox_builder.setEditText("")        self.comboBox_cause.setEditText("")        self.comboBox_divers.setEditText("")        self.comboBox_wreck.setEditText("")        self.comboBox_composition.setEditText("")        self.comboBox_inclination.setEditText("")        self.lineEdit_depth.clear()        self.comboBox_quality_depth.setEditText("")        self.lineEdit_latitude.clear()        self.comboBox_quality_coordinates.setEditText("")        self.lineEdit_longitude.clear()        self.comboBox_consulties.setEditText("")        self.lineEdit_l.clear()        self.lineEdit_w.clear()        self.lineEdit_d.clear()        self.lineEdit_t.clear()        self.lineEdit_cl.clear()        self.lineEdit_cw.clear()        self.lineEdit_cd.clear()        self.lineEdit_nickname.clear()        self.lineEdit_date_built.clear()        self.lineEdit_date_lost.clear()        self.textEdit_description.clear()        self.textEdit_history.clear()        for i in range(list):            self.tableWidget_list.removeRow(0)        self.insert_new_row("self.tableWidget_list")         self.comboBox_name.setEditText("")                self.comboBox_status.setEditText("")               def fill_fields(self, n=0):        self.rec_num = n        #QMessageBox.warning(self, "Test", str(self.comboBox_per_fin.currentText()),  QMessageBox.Ok)        try:            str(self.comboBox_code.setEditText(self.DATA_LIST[self.rec_num].code_id))            str(self.comboBox_name_vessel.setEditText(self.DATA_LIST[self.rec_num].name_vessel))            str(self.lineEdit_yard.setText(self.DATA_LIST[self.rec_num].yard))            str(self.comboBox_area.setEditText(self.DATA_LIST[self.rec_num].area))            str(self.comboBox_category.setEditText(self.DATA_LIST[self.rec_num].category))            str(self.comboBox_confidence.setEditText(self.DATA_LIST[self.rec_num].confidence))            str(self.comboBox_propulsion.setEditText(self.DATA_LIST[self.rec_num].propulsion))            str(self.comboBox_material.setEditText(self.DATA_LIST[self.rec_num].material))            str(self.comboBox_nationality.setEditText(self.DATA_LIST[self.rec_num].nationality))            str(self.comboBox_type.setEditText(self.DATA_LIST[self.rec_num].type))            str(self.comboBox_owner.setEditText(self.DATA_LIST[self.rec_num].owner))            str(self.comboBox_purpose.setEditText(self.DATA_LIST[self.rec_num].purpose))            str(self.comboBox_builder.setEditText(self.DATA_LIST[self.rec_num].builder))            str(self.comboBox_cause.setEditText(self.DATA_LIST[self.rec_num].cause))            str(self.comboBox_divers.setEditText(self.DATA_LIST[self.rec_num].divers))            str(self.comboBox_wreck.setEditText(self.DATA_LIST[self.rec_num].wreck))            str(self.comboBox_composition.setEditText(self.DATA_LIST[self.rec_num].composition))            str(self.comboBox_inclination.setEditText(self.DATA_LIST[self.rec_num].inclination))                        str(self.lineEdit_depth.setText(self.DATA_LIST[self.rec_num].depth_max_min))            str(self.comboBox_quality_depth.setEditText(self.DATA_LIST[self.rec_num].depth_quality))            str(self.lineEdit_latitude.setText(self.DATA_LIST[self.rec_num].latitude))            str(self.comboBox_quality_coordinates.setEditText(self.DATA_LIST[self.rec_num].position_quality_1))            str(self.lineEdit_longitude.setText(self.DATA_LIST[self.rec_num].longitude))            str(self.comboBox_consulties.setEditText(self.DATA_LIST[self.rec_num].consulties))                        if self.DATA_LIST[self.rec_num].l == None:                str(self.lineEdit_l.setText(""))            else:                self.lineEdit_l.setText(str(self.DATA_LIST[self.rec_num].l))                            if self.DATA_LIST[self.rec_num].w == None:                str(self.lineEdit_w.setText(""))            else:                self.lineEdit_w.setText(str(self.DATA_LIST[self.rec_num].w))            if self.DATA_LIST[self.rec_num].d == None:                str(self.lineEdit_d.setText(""))            else:                self.lineEdit_d.setText(str(self.DATA_LIST[self.rec_num].d))                        if self.DATA_LIST[self.rec_num].t == None:                str(self.lineEdit_t.setText(""))            else:                self.lineEdit_t.setText(str(self.DATA_LIST[self.rec_num].t))            if self.DATA_LIST[self.rec_num].cl == None:                str(self.lineEdit_cl.setText(""))            else:                self.lineEdit_cl.setText(str(self.DATA_LIST[self.rec_num].cl))            if self.DATA_LIST[self.rec_num].cw == None:                str(self.lineEdit_cw.setText(""))            else:                self.lineEdit_cw.setText(str(self.DATA_LIST[self.rec_num].cw))             if self.DATA_LIST[self.rec_num].cd == None:                str(self.lineEdit_cd.setText(""))            else:                self.lineEdit_cd.setText(str(self.DATA_LIST[self.rec_num].cd))                        str(self.lineEdit_nickname.setText(self.DATA_LIST[self.rec_num].nickname))            str(self.lineEdit_date_built.setText(self.DATA_LIST[self.rec_num].date_built))            str(self.lineEdit_date_lost.setText(self.DATA_LIST[self.rec_num].date_lost))            str(self.textEdit_description.setText(self.DATA_LIST[self.rec_num].description))            str(self.textEdit_history.setText(self.DATA_LIST[self.rec_num].history))            self.tableInsertData("self.tableWidget_list", self.DATA_LIST[self.rec_num].list)            str(self.comboBox_name.setEditText(self.DATA_LIST[self.rec_num].name))             str(self.comboBox_status.setEditText(self.DATA_LIST[self.rec_num].status))              if self.toolButtonPreviewMedia.isChecked() == True:                self.loadMediaPreview()                self.loadMedialist()                            except: #Exception as e:            pass#QMessageBox.warning(self, "Errore Fill Fields", str(e),  QMessageBox.Ok)           def generate_list_foto(self):        data_list_foto = []        for i in range(len(self.DATA_LIST)):                            conn = Connection()                                    thumb_path = conn.thumb_path()            thumb_path_str = thumb_path['thumb_path']                                    search_dict = {'id_entity': "'"+ str(eval("self.DATA_LIST[i].id_shipwreck"))+"'", 'entity_type' : "'SHIPWRECK'"}                        record_doc_list = self.DB_MANAGER.query_bool(search_dict, 'MEDIAVIEW')                                         for e in record_doc_list:                            thumbnail = (thumb_path_str+e.filepath)                foto= (e.id_media)                              data_list_foto.append([                    str(self.DATA_LIST[i].code_id),                                    #1 - Sito                    str(self.DATA_LIST[i].latitude),                    str(self.DATA_LIST[i].longitude),                    str(self.DATA_LIST[i].name_vessel),                                  #2 -                     str(self.DATA_LIST[i].description),                    str(foto),#5                    str(thumbnail)])#6                    return data_list_foto        def generate_list_pdf(self):        data_list = []        for i in range(len(self.DATA_LIST)):                        data_list.append([            str(self.DATA_LIST[i].code_id),            str(self.DATA_LIST[i].name_vessel),            str(self.DATA_LIST[i].yard),            str(self.DATA_LIST[i].area),            str(self.DATA_LIST[i].category),            str(self.DATA_LIST[i].confidence),            str(self.DATA_LIST[i].propulsion),            str(self.DATA_LIST[i].material),            str(self.DATA_LIST[i].nationality),            str(self.DATA_LIST[i].type),            str(self.DATA_LIST[i].owner),            str(self.DATA_LIST[i].purpose),            str(self.DATA_LIST[i].builder),            str(self.DATA_LIST[i].cause),            str(self.DATA_LIST[i].divers),            str(self.DATA_LIST[i].wreck),            str(self.DATA_LIST[i].composition),            str(self.DATA_LIST[i].inclination),            str(self.DATA_LIST[i].depth_max_min),            str(self.DATA_LIST[i].depth_quality),            str(self.DATA_LIST[i].latitude),            str(self.DATA_LIST[i].position_quality_1),            str(self.DATA_LIST[i].longitude),            str(self.DATA_LIST[i].consulties),            str(self.DATA_LIST[i].l),            str(self.DATA_LIST[i].w),            str(self.DATA_LIST[i].d),            str(self.DATA_LIST[i].t),            str(self.DATA_LIST[i].cl),            str(self.DATA_LIST[i].cw),            str(self.DATA_LIST[i].cd),            str(self.DATA_LIST[i].nickname),            str(self.DATA_LIST[i].date_built),            str(self.DATA_LIST[i].date_lost),            str(self.DATA_LIST[i].description),            str(self.DATA_LIST[i].history),            str(self.DATA_LIST[i].list),            str(self.DATA_LIST[i].status)            ])        return data_list    def generate_list_pdf2(self):        data_list = []        for i in range(len(self.DATA_LIST)):                        data_list.append([            str(self.DATA_LIST[i].code_id),            str(self.DATA_LIST[i].name_vessel),            str(self.DATA_LIST[i].nickname),            str(self.DATA_LIST[i].latitude),            str(self.DATA_LIST[i].longitude),            str(self.DATA_LIST[i].owner),            str(self.DATA_LIST[i].nationality)                        ])        return data_list            def on_pushButton_print_pressed(self):                       if self.checkBox_s_pottery.isChecked():            SHIPWRECK_pdf_sheet = generate_SHIPWRECK_pdf()            data_list = self.generate_list_pdf()            SHIPWRECK_pdf_sheet.build_SHIPWRECK_sheets(data_list)            QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)        else:               pass            if self.checkBox_e_pottery.isChecked() :            SHIPWRECK_index_pdf = generate_SHIPWRECK_pdf()            data_list = self.generate_list_pdf2()                        try:                               if bool(data_list):                    SHIPWRECK_index_pdf.build_index_SHIPWRECK(data_list, data_list[0][0])                     QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                else:                    QMessageBox.warning(self, 'Warning',"List  can't to be exported, you must fill before the form",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)        else:            pass            if self.checkBox_e_foto_t.isChecked():            SHIPWRECK_index_pdf = generate_SHIPWRECK_pdf()            data_list_foto = self.generate_list_foto()                try:                    if bool(data_list_foto):                        SHIPWRECK_index_pdf.build_index_Foto(data_list_foto, data_list_foto[0][0])                        QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                                                       else:                        QMessageBox.warning(self, 'Warning',"Photo list can't to be exported, you must tag before the pics",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)                if self.checkBox_e_foto.isChecked():            SHIPWRECK_index_pdf = generate_SHIPWRECK_pdf()            data_list_foto = self.generate_list_foto()                try:                    if bool(data_list_foto):                        SHIPWRECK_index_pdf.build_index_Foto_2(data_list_foto, data_list_foto[0][0])                        QMessageBox.warning(self, 'Ok',"Export completed",QMessageBox.Ok)                                                       else:                        QMessageBox.warning(self, 'Warniong',"Photo list can't to be exported because the image are not tagged",QMessageBox.Ok)            except Exception as e :                QMessageBox.warning(self, 'Warning',str(e),QMessageBox.Ok)    def on_pushButton_exppdf_pressed(self):        SHIPWRECK_pdf_sheet = generate_SHIPWRECK_pdf()        data_list = self.generate_list_pdf()        SHIPWRECK_pdf_sheet.build_SHIPWRECK_sheets(data_list)    def on_pushButton_explist_pressed(self):        SHIPWRECK_index_pdf = generate_SHIPWRECK_pdf()        data_list = self.generate_list_pdf2()        SHIPWRECK_index_pdf.build_index_SHIPWRECK(data_list, data_list[0][0])    def set_rec_counter(self, t, c):        self.rec_tot = t        self.rec_corr = c        self.label_rec_tot.setText(str(self.rec_tot))        self.label_rec_corrente.setText(str(self.rec_corr))    def set_LIST_REC_TEMP(self):        list = self.table2dict("self.tableWidget_list")        ##for float field                if self.lineEdit_l.text() == "":            l = None        else:            l= self.lineEdit_l.text()        if self.lineEdit_w.text() == "":            w = None        else:            w = self.lineEdit_w.text()        if self.lineEdit_d.text() == "":            d = None        else:            d = self.lineEdit_d.text()        if self.lineEdit_t.text() == "":            t = None        else:            t = self.lineEdit_t.text()        if self.lineEdit_cl.text() == "":            cl = None        else:            cl = self.lineEdit_cl.text()        if self.lineEdit_cw.text() == "":            cw = None        else:            cw = self.lineEdit_cw.text()            if self.lineEdit_cd.text() == "":            cd = None        else:            cd = self.lineEdit_cd.text()                  #data        self.DATA_LIST_REC_TEMP = [        str(self.comboBox_code.currentText()),        str(self.comboBox_name_vessel.currentText()),        str(self.lineEdit_yard.text()),        str(self.comboBox_area.currentText()),  #2 - Area        str(self.comboBox_category.currentText()),        str(self.comboBox_confidence.currentText()),        str(self.comboBox_propulsion.currentText()),#3 - US        str(self.comboBox_material.currentText()),                                         str(self.comboBox_nationality.currentText()),                                   #6 - descrizione        str(self.comboBox_type.currentText()),                                   #7 - interpretazione        str(self.comboBox_owner.currentText()),        str(self.comboBox_purpose.currentText()),        str(self.comboBox_builder.currentText()),        str(self.comboBox_cause.currentText()),        str(self.comboBox_divers.currentText()),        str(self.comboBox_wreck.currentText()),        str(self.comboBox_composition.currentText()),        str(self.comboBox_inclination.currentText()),        str(self.lineEdit_depth.text()),        str(self.comboBox_quality_depth.currentText()),        str(self.lineEdit_latitude.text()),        str(self.comboBox_quality_coordinates.currentText()),        str(self.lineEdit_longitude.text()),        str(self.comboBox_consulties.currentText()),        l,        w,        d,        t,        cl,        cw,        cd,        str(self.lineEdit_nickname.text()),        str(self.lineEdit_date_built.text()),        str(self.lineEdit_date_lost.text()),        str(self.textEdit_description.toPlainText()),        str(self.textEdit_history.toPlainText()),        str(list),        str(self.comboBox_name.currentText()),        str(self.comboBox_status.currentText()),        ]    def set_LIST_REC_CORR(self):        self.DATA_LIST_REC_CORR = []        for i in self.TABLE_FIELDS:            self.DATA_LIST_REC_CORR.append(eval("str(self.DATA_LIST[self.REC_CORR]." + i + ")"))    def records_equal_check(self):        self.set_LIST_REC_TEMP()        self.set_LIST_REC_CORR()        #QMessageBox.warning(self, "Error", str(self.DATA_LIST_REC_CORR) + str(self.DATA_LIST_REC_TEMP),  QMessageBox.Ok)        if self.DATA_LIST_REC_CORR == self.DATA_LIST_REC_TEMP:            return 0        else:            return 1    def setComboBoxEditable(self, f, n):        field_names = f        value = n        for fn in field_names:            cmd = ('%s%s%s%s') % (fn, '.setEditable(', n, ')')            eval(cmd)    def setComboBoxEnable(self, f, v):        field_names = f        value = v        for fn in field_names:            cmd = ('%s%s%s%s') % (fn, '.setEnabled(', v, ')')            eval(cmd)    def setTableEnable(self, t, v):        tab_names = t        value = v        for tn in tab_names:            cmd = ('%s%s%s%s') % (tn, '.setEnabled(', v, ')')            eval(cmd)    def testing(self, name_file, message):        f = open(str(name_file), 'w')        f.write(str(message))        f.close()    def on_pushButton_ship_pressed(self):        #site = str(self.comboBox_nationality.currentText())        self.pyQGIS.charge_shipwreck_geometry(["16"])#,"nationality", site)     # def on_pushButton_exptab_pressed(self):        # cmd = 'python3'        # subprocess.call([cmd,'{}'.format(os.path.join(os.path.dirname(__file__), 'Excel_anch.py'))])    def on_pushButton_open_dir_pressed(self):        HOME = os.environ['HFF_HOME']        path = '{}{}{}'.format(HOME, os.sep, "HFF_PDF_folder")        if platform.system() == "Windows":            os.startfile(path)        elif platform.system() == "Darwin":            subprocess.Popen(["open", path])        else:            subprocess.Popen(["xdg-open", path])# ## Class end# if __name__ == "__main__":    # app = QApplication(sys.argv)    # ui = hff_system__ANC()    # ui.show()    # sys.exit(app.exec_())